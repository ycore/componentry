import fs from 'node:fs/promises';
import path from 'node:path';
import { glob } from 'glob';
import { parse } from 'node-html-parser';
import type { Plugin } from 'vite';
import type { IconSpriteConfig } from '../@types/icon-spritesheet.types';

export function iconSpritesheets(args: IconSpriteConfig | IconSpriteConfig[]) {
  const configs = Array.isArray(args) ? args : [args];
  const spriteSheetFiles = configs.map(config => config.spriteFileName);

  return configs.map((config, index) => {
    const { inputDir, outputDir, spriteFileName = 'icon-sprites.svg', typesFileName, inputFilespec, ignoreLimit = true, nameTransformer } = config;
    const spritesheetFactory = async () => createSpritesheet({ inputDir, outputDir, spriteFileName, typesFileName, inputFilespec, nameTransformer });

    return {
      name: `icon-spritesheet${index > 0 ? index.toString() : ''}`,
      async buildStart() {
        await spritesheetFactory();
      },
      config(config) {
        if (index === 0 && ignoreLimit !== false) {
          // Auto-configure assetsInlineLimit for spriteSheetFiles
          const originalLimit = config.build?.assetsInlineLimit || 4096;

          config.build = config.build || {};
          config.build.assetsInlineLimit = (filePath: string, content: Buffer) => {
            // Don't inline any sprite files, regardless of size to avoid CORS issues
            const isSprite = spriteSheetFiles.some(spriteFile => filePath.includes(spriteFile));
            if (isSprite) return false;

            // For non-sprite files, use original limit logic
            if (typeof originalLimit === 'function') {
              return originalLimit(filePath, content);
            }

            // If originalLimit is a number, check if content size exceeds it
            return content.length <= originalLimit ? undefined : false;
          };
        }
      },
    } satisfies Plugin<IconSpriteConfig>;
  });
}

export const createSpritesheet = async ({ inputDir, outputDir, spriteFileName, typesFileName, inputFilespec, nameTransformer }: IconSpriteConfig) => {
  const outputFilePath = path.join(outputDir, spriteFileName);
  const files = glob.sync(inputFilespec || ['**/*.svg'], { cwd: inputDir });
  if (files.length === 0) {
    console.warn(`⚠️  No SVG files found in ${inputDir}`);
    return;
  }

  const symbols = await Promise.all(
    files.map(async file => {
      const inputFilePath = path.join(inputDir, file);
      const rootNode = await readSvgFile(inputFilePath);
      const svgNode = rootNode.querySelector('svg');
      if (!svgNode) {
        console.warn(`⚠️ No SVG element found in ${file}`);
        return;
      }

      svgNode.tagName = 'symbol';
      svgNode.setAttribute('id', transformIconName(file, nameTransformer));
      for (const attr of ['xmlns', 'xmlns:xlink', 'version', 'width', 'height']) {
        svgNode.removeAttribute(attr);
      }
      return svgNode.toString().trim();
    })
  );
  const svgContent = svgFileTemplate(symbols);
  await writeChangedFile(outputFilePath, svgContent, files.length);

  // write types file if typesFileName exists
  if (typesFileName) {
    const names = files.map((file: string) => transformIconName(file, nameTransformer));
    const typesContent = svgTypesTemplate(names);
    await writeChangedFile(typesFileName, typesContent, files.length);
  }
};

function transformIconName(fileName: string, transformer?: (iconName: string) => string): string {
  const strippedName = fileName.replace(/\..*?$/, '');
  return (transformer || kebabToPascal)(strippedName);
}

function kebabToPascal(str: string): string {
  return str
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function svgFileTemplate(symbols: (string | undefined)[]): string {
  return [
    // https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs
    '<?xml version="1.0" encoding="UTF-8"?>',
    '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">',
    '<defs>',
    ...symbols.filter(Boolean),
    '</defs>',
    '</svg>',
  ].join('\n');
}

function svgTypesTemplate(names: (string | undefined)[]): string {
  return ['// Generated by icon-spritesheet', '', 'export const iconNames = [', ...names.map(name => `  '${name}',`), '] as const', '', 'export type IconName = typeof iconNames[number]', ''].join('\n');
}

async function readSvgFile(filePath: string) {
  const input = await fs.readFile(filePath, 'utf8');
  return parse(input);
}

async function writeChangedFile(filepath: string, newContent: string, count: number) {
  try {
    const dirPath = path.dirname(filepath);
    await fs.mkdir(dirPath, { recursive: true });
    console.info(`*️⃣  Processing ${count} sprites for: ${filepath}`);

    const existingContent = await fs.readFile(filepath, 'utf8');
    if (existingContent !== newContent) {
      await fs.writeFile(filepath, newContent, 'utf8');
      console.info(`  ✅ Updated SVG sprite: ${filepath}`);
    }
  } catch (_e) {
    await fs.writeFile(filepath, newContent, 'utf8');
    console.info(`  ✅ Created SVG sprite: ${filepath}`);
  }
}
