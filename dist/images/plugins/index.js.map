{
  "version": 3,
  "sources": ["../../../src/images/plugins/icon-spritesheet.ts", "../../../../../node_modules/@isaacs/balanced-match/dist/esm/index.js", "../../../../../node_modules/@isaacs/brace-expansion/dist/esm/index.js", "../../../../../node_modules/minimatch/dist/esm/assert-valid-pattern.js", "../../../../../node_modules/minimatch/dist/esm/brace-expressions.js", "../../../../../node_modules/minimatch/dist/esm/unescape.js", "../../../../../node_modules/minimatch/dist/esm/ast.js", "../../../../../node_modules/minimatch/dist/esm/escape.js", "../../../../../node_modules/minimatch/dist/esm/index.js", "../../../../../node_modules/glob/dist/esm/glob.js", "../../../../../node_modules/lru-cache/dist/esm/index.js", "../../../../../node_modules/path-scurry/dist/esm/index.js", "../../../../../node_modules/minipass/dist/esm/index.js", "../../../../../node_modules/glob/dist/esm/pattern.js", "../../../../../node_modules/glob/dist/esm/ignore.js", "../../../../../node_modules/glob/dist/esm/processor.js", "../../../../../node_modules/glob/dist/esm/walker.js", "../../../../../node_modules/glob/dist/esm/has-magic.js", "../../../../../node_modules/glob/dist/esm/index.js"],
  "sourcesContent": [
    "import fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { glob } from 'glob';\nimport { parse } from 'node-html-parser';\nimport type { Plugin } from 'vite';\nimport type { IconSpriteConfig } from '../@types/icon-spritesheet.types';\n\nexport function iconSpritesheets(args: IconSpriteConfig | IconSpriteConfig[]) {\n  const configs = Array.isArray(args) ? args : [args];\n  const spriteSheetFiles = configs.map(config => config.spriteFileName);\n\n  return configs.map((config, index) => {\n    const { inputDir, outputDir, spriteFileName = 'icon-sprites.svg', typesFileName, inputFilespec, ignoreLimit = true, nameTransformer } = config;\n    const spritesheetFactory = async () => createSpritesheet({ inputDir, outputDir, spriteFileName, typesFileName, inputFilespec, nameTransformer });\n\n    return {\n      name: `icon-spritesheet${index > 0 ? index.toString() : ''}`,\n      async buildStart() {\n        await spritesheetFactory();\n      },\n      config(config) {\n        if (index === 0 && ignoreLimit !== false) {\n          // Auto-configure assetsInlineLimit for spriteSheetFiles\n          const originalLimit = config.build?.assetsInlineLimit || 4096;\n\n          config.build = config.build || {};\n          config.build.assetsInlineLimit = (filePath: string, content: Buffer) => {\n            // Don't inline any sprite files, regardless of size to avoid CORS issues\n            const isSprite = spriteSheetFiles.some(spriteFile => filePath.includes(spriteFile));\n            if (isSprite) return false;\n\n            // For non-sprite files, use original limit logic\n            if (typeof originalLimit === 'function') {\n              return originalLimit(filePath, content);\n            }\n\n            // If originalLimit is a number, check if content size exceeds it\n            return content.length <= originalLimit ? undefined : false;\n          };\n        }\n      },\n    } satisfies Plugin<IconSpriteConfig>;\n  });\n}\n\nexport const createSpritesheet = async ({ inputDir, outputDir, spriteFileName, typesFileName, inputFilespec, nameTransformer }: IconSpriteConfig) => {\n  const outputFilePath = path.join(outputDir, spriteFileName);\n  const files = glob.sync(inputFilespec || ['**/*.svg'], { cwd: inputDir });\n  if (files.length === 0) {\n    console.warn(`⚠️  No SVG files found in ${inputDir}`);\n    return;\n  }\n\n  const symbols = await Promise.all(\n    files.map(async file => {\n      const inputFilePath = path.join(inputDir, file);\n      const rootNode = await readSvgFile(inputFilePath);\n      const svgNode = rootNode.querySelector('svg');\n      if (!svgNode) {\n        console.warn(`⚠️ No SVG element found in ${file}`);\n        return;\n      }\n\n      svgNode.tagName = 'symbol';\n      svgNode.setAttribute('id', transformIconName(file, nameTransformer));\n      for (const attr of ['xmlns', 'xmlns:xlink', 'version', 'width', 'height']) {\n        svgNode.removeAttribute(attr);\n      }\n      return svgNode.toString().trim();\n    })\n  );\n  const svgContent = svgFileTemplate(symbols);\n  await writeChangedFile(outputFilePath, svgContent, files.length);\n\n  // write types file if typesFileName exists\n  if (typesFileName) {\n    const names = files.map((file: string) => transformIconName(file, nameTransformer));\n    const typesContent = svgTypesTemplate(names);\n    await writeChangedFile(typesFileName, typesContent, files.length);\n  }\n};\n\nfunction transformIconName(fileName: string, transformer?: (iconName: string) => string): string {\n  const strippedName = fileName.replace(/\\..*?$/, '');\n  return (transformer || kebabToPascal)(strippedName);\n}\n\nfunction kebabToPascal(str: string): string {\n  return str\n    .split('-')\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n    .join('');\n}\n\nfunction svgFileTemplate(symbols: (string | undefined)[]): string {\n  return [\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs\n    '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"0\" height=\"0\">',\n    '<defs>',\n    ...symbols.filter(Boolean),\n    '</defs>',\n    '</svg>',\n  ].join('\\n');\n}\n\nfunction svgTypesTemplate(names: (string | undefined)[]): string {\n  return ['// Generated by icon-spritesheet', '', 'export const iconNames = [', ...names.map(name => `  '${name}',`), '] as const', '', 'export type IconName = typeof iconNames[number]', ''].join('\\n');\n}\n\nasync function readSvgFile(filePath: string) {\n  const input = await fs.readFile(filePath, 'utf8');\n  return parse(input);\n}\n\nasync function writeChangedFile(filepath: string, newContent: string, count: number) {\n  try {\n    const dirPath = path.dirname(filepath);\n    await fs.mkdir(dirPath, { recursive: true });\n    console.info(`*️⃣  Processing ${count} sprites for: ${filepath}`);\n\n    const existingContent = await fs.readFile(filepath, 'utf8');\n    if (existingContent !== newContent) {\n      await fs.writeFile(filepath, newContent, 'utf8');\n      console.info(`  ✅ Updated SVG sprite: ${filepath}`);\n    }\n  } catch (_e) {\n    await fs.writeFile(filepath, newContent, 'utf8');\n    console.info(`  ✅ Created SVG sprite: ${filepath}`);\n  }\n}\n",
    "export const balanced = (a, b, str) => {\n    const ma = a instanceof RegExp ? maybeMatch(a, str) : a;\n    const mb = b instanceof RegExp ? maybeMatch(b, str) : b;\n    const r = ma !== null && mb != null && range(ma, mb, str);\n    return (r && {\n        start: r[0],\n        end: r[1],\n        pre: str.slice(0, r[0]),\n        body: str.slice(r[0] + ma.length, r[1]),\n        post: str.slice(r[1] + mb.length),\n    });\n};\nconst maybeMatch = (reg, str) => {\n    const m = str.match(reg);\n    return m ? m[0] : null;\n};\nexport const range = (a, b, str) => {\n    let begs, beg, left, right = undefined, result;\n    let ai = str.indexOf(a);\n    let bi = str.indexOf(b, ai + 1);\n    let i = ai;\n    if (ai >= 0 && bi > 0) {\n        if (a === b) {\n            return [ai, bi];\n        }\n        begs = [];\n        left = str.length;\n        while (i >= 0 && !result) {\n            if (i === ai) {\n                begs.push(i);\n                ai = str.indexOf(a, i + 1);\n            }\n            else if (begs.length === 1) {\n                const r = begs.pop();\n                if (r !== undefined)\n                    result = [r, bi];\n            }\n            else {\n                beg = begs.pop();\n                if (beg !== undefined && beg < left) {\n                    left = beg;\n                    right = bi;\n                }\n                bi = str.indexOf(b, i + 1);\n            }\n            i = ai < bi && ai >= 0 ? ai : bi;\n        }\n        if (begs.length && right !== undefined) {\n            result = [left, right];\n        }\n    }\n    return result;\n};\n//# sourceMappingURL=index.js.map",
    "import { balanced } from '@isaacs/balanced-match';\nconst escSlash = '\\0SLASH' + Math.random() + '\\0';\nconst escOpen = '\\0OPEN' + Math.random() + '\\0';\nconst escClose = '\\0CLOSE' + Math.random() + '\\0';\nconst escComma = '\\0COMMA' + Math.random() + '\\0';\nconst escPeriod = '\\0PERIOD' + Math.random() + '\\0';\nconst escSlashPattern = new RegExp(escSlash, 'g');\nconst escOpenPattern = new RegExp(escOpen, 'g');\nconst escClosePattern = new RegExp(escClose, 'g');\nconst escCommaPattern = new RegExp(escComma, 'g');\nconst escPeriodPattern = new RegExp(escPeriod, 'g');\nconst slashPattern = /\\\\\\\\/g;\nconst openPattern = /\\\\{/g;\nconst closePattern = /\\\\}/g;\nconst commaPattern = /\\\\,/g;\nconst periodPattern = /\\\\./g;\nfunction numeric(str) {\n    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n    return str\n        .replace(slashPattern, escSlash)\n        .replace(openPattern, escOpen)\n        .replace(closePattern, escClose)\n        .replace(commaPattern, escComma)\n        .replace(periodPattern, escPeriod);\n}\nfunction unescapeBraces(str) {\n    return str\n        .replace(escSlashPattern, '\\\\')\n        .replace(escOpenPattern, '{')\n        .replace(escClosePattern, '}')\n        .replace(escCommaPattern, ',')\n        .replace(escPeriodPattern, '.');\n}\n/**\n * Basically just str.split(\",\"), but handling cases\n * where we have nested braced sections, which should be\n * treated as individual members, like {a,{b,c},d}\n */\nfunction parseCommaParts(str) {\n    if (!str) {\n        return [''];\n    }\n    const parts = [];\n    const m = balanced('{', '}', str);\n    if (!m) {\n        return str.split(',');\n    }\n    const { pre, body, post } = m;\n    const p = pre.split(',');\n    p[p.length - 1] += '{' + body + '}';\n    const postParts = parseCommaParts(post);\n    if (post.length) {\n        ;\n        p[p.length - 1] += postParts.shift();\n        p.push.apply(p, postParts);\n    }\n    parts.push.apply(parts, p);\n    return parts;\n}\nexport function expand(str) {\n    if (!str) {\n        return [];\n    }\n    // I don't know why Bash 4.3 does this, but it does.\n    // Anything starting with {} will have the first two bytes preserved\n    // but *only* at the top level, so {},a}b will not expand to anything,\n    // but a{},b}c will be expanded to [a}c,abc].\n    // One could argue that this is a bug in Bash, but since the goal of\n    // this module is to match Bash's rules, we escape a leading {}\n    if (str.slice(0, 2) === '{}') {\n        str = '\\\\{\\\\}' + str.slice(2);\n    }\n    return expand_(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction embrace(str) {\n    return '{' + str + '}';\n}\nfunction isPadded(el) {\n    return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n    return i <= y;\n}\nfunction gte(i, y) {\n    return i >= y;\n}\nfunction expand_(str, isTop) {\n    /** @type {string[]} */\n    const expansions = [];\n    const m = balanced('{', '}', str);\n    if (!m)\n        return [str];\n    // no need to expand pre, since it is guaranteed to be free of brace-sets\n    const pre = m.pre;\n    const post = m.post.length ? expand_(m.post, false) : [''];\n    if (/\\$$/.test(m.pre)) {\n        for (let k = 0; k < post.length; k++) {\n            const expansion = pre + '{' + m.body + '}' + post[k];\n            expansions.push(expansion);\n        }\n    }\n    else {\n        const isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isSequence = isNumericSequence || isAlphaSequence;\n        const isOptions = m.body.indexOf(',') >= 0;\n        if (!isSequence && !isOptions) {\n            // {a},b}\n            if (m.post.match(/,(?!,).*\\}/)) {\n                str = m.pre + '{' + m.body + escClose + m.post;\n                return expand_(str);\n            }\n            return [str];\n        }\n        let n;\n        if (isSequence) {\n            n = m.body.split(/\\.\\./);\n        }\n        else {\n            n = parseCommaParts(m.body);\n            if (n.length === 1 && n[0] !== undefined) {\n                // x{{a,b}}y ==> x{a}y x{b}y\n                n = expand_(n[0], false).map(embrace);\n                //XXX is this necessary? Can't seem to hit it in tests.\n                /* c8 ignore start */\n                if (n.length === 1) {\n                    return post.map(p => m.pre + n[0] + p);\n                }\n                /* c8 ignore stop */\n            }\n        }\n        // at this point, n is the parts, and we know it's not a comma set\n        // with a single entry.\n        let N;\n        if (isSequence && n[0] !== undefined && n[1] !== undefined) {\n            const x = numeric(n[0]);\n            const y = numeric(n[1]);\n            const width = Math.max(n[0].length, n[1].length);\n            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;\n            let test = lte;\n            const reverse = y < x;\n            if (reverse) {\n                incr *= -1;\n                test = gte;\n            }\n            const pad = n.some(isPadded);\n            N = [];\n            for (let i = x; test(i, y); i += incr) {\n                let c;\n                if (isAlphaSequence) {\n                    c = String.fromCharCode(i);\n                    if (c === '\\\\') {\n                        c = '';\n                    }\n                }\n                else {\n                    c = String(i);\n                    if (pad) {\n                        const need = width - c.length;\n                        if (need > 0) {\n                            const z = new Array(need + 1).join('0');\n                            if (i < 0) {\n                                c = '-' + z + c.slice(1);\n                            }\n                            else {\n                                c = z + c;\n                            }\n                        }\n                    }\n                }\n                N.push(c);\n            }\n        }\n        else {\n            N = [];\n            for (let j = 0; j < n.length; j++) {\n                N.push.apply(N, expand_(n[j], false));\n            }\n        }\n        for (let j = 0; j < N.length; j++) {\n            for (let k = 0; k < post.length; k++) {\n                const expansion = pre + N[j] + post[k];\n                if (!isTop || isSequence || expansion) {\n                    expansions.push(expansion);\n                }\n            }\n        }\n    }\n    return expansions;\n}\n//# sourceMappingURL=index.js.map",
    "const MAX_PATTERN_LENGTH = 1024 * 64;\nexport const assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\n//# sourceMappingURL=assert-valid-pattern.js.map",
    "// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\n//# sourceMappingURL=brace-expressions.js.map",
    "/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\n//# sourceMappingURL=unescape.js.map",
    "// parse a single path portion\nimport { parseClass } from './brace-expressions.js';\nimport { unescape } from './unescape.js';\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nexport class AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                unescape(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, unescape(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            unescape(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = parseClass(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, unescape(glob), !!hasMagic, uflag];\n    }\n}\n//# sourceMappingURL=ast.js.map",
    "/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\n//# sourceMappingURL=escape.js.map",
    "import { expand } from '@isaacs/brace-expansion';\nimport { assertValidPattern } from './assert-valid-pattern.js';\nimport { AST } from './ast.js';\nimport { escape } from './escape.js';\nimport { unescape } from './unescape.js';\nexport const minimatch = (p, pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nminimatch.sep = sep;\nexport const GLOBSTAR = Symbol('globstar **');\nminimatch.GLOBSTAR = GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nexport const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);\nminimatch.filter = filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nexport const defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: GLOBSTAR,\n    });\n};\nminimatch.defaults = defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return expand(pattern);\n};\nminimatch.braceExpand = braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nexport const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nminimatch.makeRe = makeRe;\nexport const match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nminimatch.match = match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nexport class Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        assertValidPattern(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern) {\n        assertValidPattern(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === GLOBSTAR\n                        ? GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== GLOBSTAR || prev === GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js';\nexport { escape } from './escape.js';\nexport { unescape } from './unescape.js';\n/* c8 ignore stop */\nminimatch.AST = AST;\nminimatch.Minimatch = Minimatch;\nminimatch.escape = escape;\nminimatch.unescape = unescape;\n//# sourceMappingURL=index.js.map",
    "import { Minimatch } from 'minimatch';\nimport { fileURLToPath } from 'node:url';\nimport { PathScurry, PathScurryDarwin, PathScurryPosix, PathScurryWin32, } from 'path-scurry';\nimport { Pattern } from './pattern.js';\nimport { GlobStream, GlobWalker } from './walker.js';\n// if no process global, just call it linux.\n// so we default to case-sensitive, / separators\nconst defaultPlatform = (typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string') ?\n    process.platform\n    : 'linux';\n/**\n * An object that can perform glob pattern traversals.\n */\nexport class Glob {\n    absolute;\n    cwd;\n    root;\n    dot;\n    dotRelative;\n    follow;\n    ignore;\n    magicalBraces;\n    mark;\n    matchBase;\n    maxDepth;\n    nobrace;\n    nocase;\n    nodir;\n    noext;\n    noglobstar;\n    pattern;\n    platform;\n    realpath;\n    scurry;\n    stat;\n    signal;\n    windowsPathsNoEscape;\n    withFileTypes;\n    includeChildMatches;\n    /**\n     * The options provided to the constructor.\n     */\n    opts;\n    /**\n     * An array of parsed immutable {@link Pattern} objects.\n     */\n    patterns;\n    /**\n     * All options are stored as properties on the `Glob` object.\n     *\n     * See {@link GlobOptions} for full options descriptions.\n     *\n     * Note that a previous `Glob` object can be passed as the\n     * `GlobOptions` to another `Glob` instantiation to re-use settings\n     * and caches with a new pattern.\n     *\n     * Traversal functions can be called multiple times to run the walk\n     * again.\n     */\n    constructor(pattern, opts) {\n        /* c8 ignore start */\n        if (!opts)\n            throw new TypeError('glob options required');\n        /* c8 ignore stop */\n        this.withFileTypes = !!opts.withFileTypes;\n        this.signal = opts.signal;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.dotRelative = !!opts.dotRelative;\n        this.nodir = !!opts.nodir;\n        this.mark = !!opts.mark;\n        if (!opts.cwd) {\n            this.cwd = '';\n        }\n        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {\n            opts.cwd = fileURLToPath(opts.cwd);\n        }\n        this.cwd = opts.cwd || '';\n        this.root = opts.root;\n        this.magicalBraces = !!opts.magicalBraces;\n        this.nobrace = !!opts.nobrace;\n        this.noext = !!opts.noext;\n        this.realpath = !!opts.realpath;\n        this.absolute = opts.absolute;\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        this.noglobstar = !!opts.noglobstar;\n        this.matchBase = !!opts.matchBase;\n        this.maxDepth =\n            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;\n        this.stat = !!opts.stat;\n        this.ignore = opts.ignore;\n        if (this.withFileTypes && this.absolute !== undefined) {\n            throw new Error('cannot set absolute and withFileTypes:true');\n        }\n        if (typeof pattern === 'string') {\n            pattern = [pattern];\n        }\n        this.windowsPathsNoEscape =\n            !!opts.windowsPathsNoEscape ||\n                opts.allowWindowsEscape ===\n                    false;\n        if (this.windowsPathsNoEscape) {\n            pattern = pattern.map(p => p.replace(/\\\\/g, '/'));\n        }\n        if (this.matchBase) {\n            if (opts.noglobstar) {\n                throw new TypeError('base matching requires globstar');\n            }\n            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));\n        }\n        this.pattern = pattern;\n        this.platform = opts.platform || defaultPlatform;\n        this.opts = { ...opts, platform: this.platform };\n        if (opts.scurry) {\n            this.scurry = opts.scurry;\n            if (opts.nocase !== undefined &&\n                opts.nocase !== opts.scurry.nocase) {\n                throw new Error('nocase option contradicts provided scurry option');\n            }\n        }\n        else {\n            const Scurry = opts.platform === 'win32' ? PathScurryWin32\n                : opts.platform === 'darwin' ? PathScurryDarwin\n                    : opts.platform ? PathScurryPosix\n                        : PathScurry;\n            this.scurry = new Scurry(this.cwd, {\n                nocase: opts.nocase,\n                fs: opts.fs,\n            });\n        }\n        this.nocase = this.scurry.nocase;\n        // If you do nocase:true on a case-sensitive file system, then\n        // we need to use regexps instead of strings for non-magic\n        // path portions, because statting `aBc` won't return results\n        // for the file `AbC` for example.\n        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';\n        const mmo = {\n            // default nocase based on platform\n            ...opts,\n            dot: this.dot,\n            matchBase: this.matchBase,\n            nobrace: this.nobrace,\n            nocase: this.nocase,\n            nocaseMagicOnly,\n            nocomment: true,\n            noext: this.noext,\n            nonegate: true,\n            optimizationLevel: 2,\n            platform: this.platform,\n            windowsPathsNoEscape: this.windowsPathsNoEscape,\n            debug: !!this.opts.debug,\n        };\n        const mms = this.pattern.map(p => new Minimatch(p, mmo));\n        const [matchSet, globParts] = mms.reduce((set, m) => {\n            set[0].push(...m.set);\n            set[1].push(...m.globParts);\n            return set;\n        }, [[], []]);\n        this.patterns = matchSet.map((set, i) => {\n            const g = globParts[i];\n            /* c8 ignore start */\n            if (!g)\n                throw new Error('invalid pattern object');\n            /* c8 ignore stop */\n            return new Pattern(set, g, 0, this.platform);\n        });\n    }\n    async walk() {\n        // Walkers always return array of Path objects, so we just have to\n        // coerce them into the right shape.  It will have already called\n        // realpath() if the option was set to do so, so we know that's cached.\n        // start out knowing the cwd, at least\n        return [\n            ...(await new GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ?\n                    this.maxDepth + this.scurry.cwd.depth()\n                    : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches,\n            }).walk()),\n        ];\n    }\n    walkSync() {\n        return [\n            ...new GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ?\n                    this.maxDepth + this.scurry.cwd.depth()\n                    : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches,\n            }).walkSync(),\n        ];\n    }\n    stream() {\n        return new GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ?\n                this.maxDepth + this.scurry.cwd.depth()\n                : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches,\n        }).stream();\n    }\n    streamSync() {\n        return new GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ?\n                this.maxDepth + this.scurry.cwd.depth()\n                : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches,\n        }).streamSync();\n    }\n    /**\n     * Default sync iteration function. Returns a Generator that\n     * iterates over the results.\n     */\n    iterateSync() {\n        return this.streamSync()[Symbol.iterator]();\n    }\n    [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    /**\n     * Default async iteration function. Returns an AsyncGenerator that\n     * iterates over the results.\n     */\n    iterate() {\n        return this.stream()[Symbol.asyncIterator]();\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n}\n//# sourceMappingURL=glob.js.map",
    "/**\n * @module LRUCache\n */\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache {\n    // options that cannot be changed without disaster\n    #max;\n    #maxSize;\n    #dispose;\n    #onInsert;\n    #disposeAfter;\n    #fetchMethod;\n    #memoMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    #hasOnInsert;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get memoMethod() {\n        return this.#memoMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.onInsert} (read-only)\n     */\n    get onInsert() {\n        return this.#onInsert;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (memoMethod !== undefined &&\n            typeof memoMethod !== 'function') {\n            throw new TypeError('memoMethod must be a function if defined');\n        }\n        this.#memoMethod = memoMethod;\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof onInsert === 'function') {\n            this.#onInsert = onInsert;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasOnInsert = !!this.#onInsert;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the number of ms left in the item's TTL. If item is not in cache,\n     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.#delete(this.#keyList[index], 'expire');\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */\n    [Symbol.toStringTag] = 'LRUCache';\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from most\n     * recently used to least recently used.\n     *\n     * `fn` is called as `fn(value, key, cache)`.\n     *\n     * If `thisp` is provided, function will be called in the `this`-context of\n     * the provided object, or the cache if no `thisp` object is provided.\n     *\n     * Does not update age or recenty of use, or iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.#delete(this.#keyList[i], 'expire');\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Returns `undefined` if the key is not present.\n     *\n     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n     * serialization, the `start` value is always the current timestamp, and the\n     * `ttl` is a calculated remaining time to live (negative if expired).\n     *\n     * Always returns stale values, if their info is found in the cache, so be\n     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n     * if relevant.\n     */\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v)\n            ? v.__staleWhileFetching\n            : v;\n        if (value === undefined)\n            return undefined;\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to {@link LRUCache#load}.\n     *\n     * The `start` fields are calculated relative to a portable `Date.now()`\n     * timestamp, even if `performance.now()` is available.\n     *\n     * Stale entries are always included in the `dump`, even if\n     * {@link LRUCache.OptionsBase.allowStale} is false.\n     *\n     * Note: this returns an actual array, not a generator, so it can be more\n     * easily passed around.\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     *\n     * The shape of the resulting cache may be different if the same options are\n     * not used in both caches.\n     *\n     * The `start` fields are assumed to be calculated relative to a portable\n     * `Date.now()` timestamp, even if `performance.now()` is available.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     *\n     * Fields on the {@link LRUCache.SetOptions} options param will override\n     * their corresponding values in the constructor options for the scope\n     * of this single `set()` operation.\n     *\n     * If `start` is provided, then that will set the effective start\n     * time for the TTL calculation. Note that this must be a previous\n     * value of `performance.now()` if supported, or a previous value of\n     * `Date.now()` if not.\n     *\n     * Options object may also include `size`, which will prevent\n     * calling the `sizeCalculation` function and just use the specified\n     * number if it is a positive integer, and `noDisposeOnSet` which\n     * will prevent calling a `dispose` function in the case of\n     * overwrites.\n     *\n     * If the `size` (or return value of `sizeCalculation`) for a given\n     * entry is greater than `maxEntrySize`, then the item will not be\n     * added to the cache.\n     *\n     * Will update the recency of the entry.\n     *\n     * If the value is `undefined`, then this is an alias for\n     * `cache.delete(key)`. `undefined` is never stored in the cache.\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.#delete(k, 'set');\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n            if (this.#hasOnInsert) {\n                this.#onInsert?.(v, k, 'add');\n            }\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n            if (this.#hasOnInsert) {\n                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Check if a key is in the cache, without updating the recency of\n     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n     * to `true` in either the options or the constructor.\n     *\n     * Will return `false` if the item is stale, even though it is technically in\n     * the cache. The difference can be determined (if it matters) by using a\n     * `status` argument, and inspecting the `has` field.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.#delete(k, 'fetch');\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.#delete(k, 'fetch');\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    async forceFetch(k, fetchOptions = {}) {\n        const v = await this.fetch(k, fetchOptions);\n        if (v === undefined)\n            throw new Error('fetch() returned undefined');\n        return v;\n    }\n    memo(k, memoOptions = {}) {\n        const memoMethod = this.#memoMethod;\n        if (!memoMethod) {\n            throw new Error('no memoMethod provided to constructor');\n        }\n        const { context, forceRefresh, ...options } = memoOptions;\n        const v = this.get(k, options);\n        if (!forceRefresh && v !== undefined)\n            return v;\n        const vv = memoMethod(k, v, {\n            options,\n            context,\n        });\n        this.set(k, vv, options);\n        return vv;\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.#delete(k, 'expire');\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     *\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        return this.#delete(k, 'delete');\n    }\n    #delete(k, reason) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.#clear(reason);\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, reason);\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, reason]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        return this.#clear('delete');\n    }\n    #clear(reason) {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, reason);\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, reason]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map",
    "import { LRUCache } from 'lru-cache';\nimport { posix, win32 } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport { lstatSync, readdir as readdirCB, readdirSync, readlinkSync, realpathSync as rps, } from 'fs';\nimport * as actualFS from 'node:fs';\nconst realpathSync = rps.native;\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nimport { lstat, readdir, readlink, realpath } from 'node:fs/promises';\nimport { Minipass } from 'minipass';\nconst defaultFS = {\n    lstatSync,\n    readdir: readdirCB,\n    readdirSync,\n    readlinkSync,\n    realpathSync,\n    promises: {\n        lstat,\n        readdir,\n        readlink,\n        realpath,\n    },\n};\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ?\n    defaultFS\n    : {\n        ...defaultFS,\n        ...fsOption,\n        promises: {\n            ...defaultFS.promises,\n            ...(fsOption.promises || {}),\n        },\n    };\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i;\nconst uncToDrive = (rootPath) => rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\');\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/;\nconst UNKNOWN = 0; // may not even exist, for all we know\nconst IFIFO = 0b0001;\nconst IFCHR = 0b0010;\nconst IFDIR = 0b0100;\nconst IFBLK = 0b0110;\nconst IFREG = 0b1000;\nconst IFLNK = 0b1010;\nconst IFSOCK = 0b1100;\nconst IFMT = 0b1111;\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT;\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 0b0000_0001_0000;\n// set after a successful lstat()\nconst LSTAT_CALLED = 0b0000_0010_0000;\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 0b0000_0100_0000;\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 0b0000_1000_0000;\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 0b0001_0000_0000;\n// set if we know realpath() will fail\nconst ENOREALPATH = 0b0010_0000_0000;\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;\nconst TYPEMASK = 0b0011_1111_1111;\nconst entToType = (s) => s.isFile() ? IFREG\n    : s.isDirectory() ? IFDIR\n        : s.isSymbolicLink() ? IFLNK\n            : s.isCharacterDevice() ? IFCHR\n                : s.isBlockDevice() ? IFBLK\n                    : s.isSocket() ? IFSOCK\n                        : s.isFIFO() ? IFIFO\n                            : UNKNOWN;\n// normalize unicode path names\nconst normalizeCache = new Map();\nconst normalize = (s) => {\n    const c = normalizeCache.get(s);\n    if (c)\n        return c;\n    const n = s.normalize('NFKD');\n    normalizeCache.set(s, n);\n    return n;\n};\nconst normalizeNocaseCache = new Map();\nconst normalizeNocase = (s) => {\n    const c = normalizeNocaseCache.get(s);\n    if (c)\n        return c;\n    const n = normalize(s.toLowerCase());\n    normalizeNocaseCache.set(s, n);\n    return n;\n};\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nexport class ResolveCache extends LRUCache {\n    constructor() {\n        super({ max: 256 });\n    }\n}\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nexport class ChildrenCache extends LRUCache {\n    constructor(maxSize = 16 * 1024) {\n        super({\n            maxSize,\n            // parent + children\n            sizeCalculation: a => a.length + 1,\n        });\n    }\n}\nconst setAsCwd = Symbol('PathScurry setAsCwd');\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nexport class PathBase {\n    /**\n     * the basename of this path\n     *\n     * **Important**: *always* test the path name against any test string\n     * usingthe {@link isNamed} method, and not by directly comparing this\n     * string. Otherwise, unicode path strings that the system sees as identical\n     * will not be properly treated as the same path, leading to incorrect\n     * behavior and possible security issues.\n     */\n    name;\n    /**\n     * the Path entry corresponding to the path root.\n     *\n     * @internal\n     */\n    root;\n    /**\n     * All roots found within the current PathScurry family\n     *\n     * @internal\n     */\n    roots;\n    /**\n     * a reference to the parent path, or undefined in the case of root entries\n     *\n     * @internal\n     */\n    parent;\n    /**\n     * boolean indicating whether paths are compared case-insensitively\n     * @internal\n     */\n    nocase;\n    /**\n     * boolean indicating that this path is the current working directory\n     * of the PathScurry collection that contains it.\n     */\n    isCWD = false;\n    // potential default fs override\n    #fs;\n    // Stats fields\n    #dev;\n    get dev() {\n        return this.#dev;\n    }\n    #mode;\n    get mode() {\n        return this.#mode;\n    }\n    #nlink;\n    get nlink() {\n        return this.#nlink;\n    }\n    #uid;\n    get uid() {\n        return this.#uid;\n    }\n    #gid;\n    get gid() {\n        return this.#gid;\n    }\n    #rdev;\n    get rdev() {\n        return this.#rdev;\n    }\n    #blksize;\n    get blksize() {\n        return this.#blksize;\n    }\n    #ino;\n    get ino() {\n        return this.#ino;\n    }\n    #size;\n    get size() {\n        return this.#size;\n    }\n    #blocks;\n    get blocks() {\n        return this.#blocks;\n    }\n    #atimeMs;\n    get atimeMs() {\n        return this.#atimeMs;\n    }\n    #mtimeMs;\n    get mtimeMs() {\n        return this.#mtimeMs;\n    }\n    #ctimeMs;\n    get ctimeMs() {\n        return this.#ctimeMs;\n    }\n    #birthtimeMs;\n    get birthtimeMs() {\n        return this.#birthtimeMs;\n    }\n    #atime;\n    get atime() {\n        return this.#atime;\n    }\n    #mtime;\n    get mtime() {\n        return this.#mtime;\n    }\n    #ctime;\n    get ctime() {\n        return this.#ctime;\n    }\n    #birthtime;\n    get birthtime() {\n        return this.#birthtime;\n    }\n    #matchName;\n    #depth;\n    #fullpath;\n    #fullpathPosix;\n    #relative;\n    #relativePosix;\n    #type;\n    #children;\n    #linkTarget;\n    #realpath;\n    /**\n     * This property is for compatibility with the Dirent class as of\n     * Node v20, where Dirent['parentPath'] refers to the path of the\n     * directory that was passed to readdir. For root entries, it's the path\n     * to the entry itself.\n     */\n    get parentPath() {\n        return (this.parent || this).fullpath();\n    }\n    /**\n     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,\n     * this property refers to the *parent* path, not the path object itself.\n     *\n     * @deprecated\n     */\n    get path() {\n        return this.parentPath;\n    }\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        this.name = name;\n        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);\n        this.#type = type & TYPEMASK;\n        this.nocase = nocase;\n        this.roots = roots;\n        this.root = root || this;\n        this.#children = children;\n        this.#fullpath = opts.fullpath;\n        this.#relative = opts.relative;\n        this.#relativePosix = opts.relativePosix;\n        this.parent = opts.parent;\n        if (this.parent) {\n            this.#fs = this.parent.#fs;\n        }\n        else {\n            this.#fs = fsFromOption(opts.fs);\n        }\n    }\n    /**\n     * Returns the depth of the Path object from its root.\n     *\n     * For example, a path at `/foo/bar` would have a depth of 2.\n     */\n    depth() {\n        if (this.#depth !== undefined)\n            return this.#depth;\n        if (!this.parent)\n            return (this.#depth = 0);\n        return (this.#depth = this.parent.depth() + 1);\n    }\n    /**\n     * @internal\n     */\n    childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Get the Path object referenced by the string path, resolved from this Path\n     */\n    resolve(path) {\n        if (!path) {\n            return this;\n        }\n        const rootPath = this.getRootString(path);\n        const dir = path.substring(rootPath.length);\n        const dirParts = dir.split(this.splitSep);\n        const result = rootPath ?\n            this.getRoot(rootPath).#resolveParts(dirParts)\n            : this.#resolveParts(dirParts);\n        return result;\n    }\n    #resolveParts(dirParts) {\n        let p = this;\n        for (const part of dirParts) {\n            p = p.child(part);\n        }\n        return p;\n    }\n    /**\n     * Returns the cached children Path objects, if still available.  If they\n     * have fallen out of the cache, then returns an empty array, and resets the\n     * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n     * lookup.\n     *\n     * @internal\n     */\n    children() {\n        const cached = this.#children.get(this);\n        if (cached) {\n            return cached;\n        }\n        const children = Object.assign([], { provisional: 0 });\n        this.#children.set(this, children);\n        this.#type &= ~READDIR_CALLED;\n        return children;\n    }\n    /**\n     * Resolves a path portion and returns or creates the child Path.\n     *\n     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n     * `'..'`.\n     *\n     * This should not be called directly.  If `pathPart` contains any path\n     * separators, it will lead to unsafe undefined behavior.\n     *\n     * Use `Path.resolve()` instead.\n     *\n     * @internal\n     */\n    child(pathPart, opts) {\n        if (pathPart === '' || pathPart === '.') {\n            return this;\n        }\n        if (pathPart === '..') {\n            return this.parent || this;\n        }\n        // find the child\n        const children = this.children();\n        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);\n        for (const p of children) {\n            if (p.#matchName === name) {\n                return p;\n            }\n        }\n        // didn't find it, create provisional child, since it might not\n        // actually exist.  If we know the parent isn't a dir, then\n        // in fact it CAN'T exist.\n        const s = this.parent ? this.sep : '';\n        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;\n        const pchild = this.newChild(pathPart, UNKNOWN, {\n            ...opts,\n            parent: this,\n            fullpath,\n        });\n        if (!this.canReaddir()) {\n            pchild.#type |= ENOENT;\n        }\n        // don't have to update provisional, because if we have real children,\n        // then provisional is set to children.length, otherwise a lower number\n        children.push(pchild);\n        return pchild;\n    }\n    /**\n     * The relative path from the cwd. If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpath()\n     */\n    relative() {\n        if (this.isCWD)\n            return '';\n        if (this.#relative !== undefined) {\n            return this.#relative;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#relative = this.name);\n        }\n        const pv = p.relative();\n        return pv + (!pv || !p.parent ? '' : this.sep) + name;\n    }\n    /**\n     * The relative path from the cwd, using / as the path separator.\n     * If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpathPosix()\n     * On posix systems, this is identical to relative().\n     */\n    relativePosix() {\n        if (this.sep === '/')\n            return this.relative();\n        if (this.isCWD)\n            return '';\n        if (this.#relativePosix !== undefined)\n            return this.#relativePosix;\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#relativePosix = this.fullpathPosix());\n        }\n        const pv = p.relativePosix();\n        return pv + (!pv || !p.parent ? '' : '/') + name;\n    }\n    /**\n     * The fully resolved path string for this Path entry\n     */\n    fullpath() {\n        if (this.#fullpath !== undefined) {\n            return this.#fullpath;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#fullpath = this.name);\n        }\n        const pv = p.fullpath();\n        const fp = pv + (!p.parent ? '' : this.sep) + name;\n        return (this.#fullpath = fp);\n    }\n    /**\n     * On platforms other than windows, this is identical to fullpath.\n     *\n     * On windows, this is overridden to return the forward-slash form of the\n     * full UNC path.\n     */\n    fullpathPosix() {\n        if (this.#fullpathPosix !== undefined)\n            return this.#fullpathPosix;\n        if (this.sep === '/')\n            return (this.#fullpathPosix = this.fullpath());\n        if (!this.parent) {\n            const p = this.fullpath().replace(/\\\\/g, '/');\n            if (/^[a-z]:\\//i.test(p)) {\n                return (this.#fullpathPosix = `//?/${p}`);\n            }\n            else {\n                return (this.#fullpathPosix = p);\n            }\n        }\n        const p = this.parent;\n        const pfpp = p.fullpathPosix();\n        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;\n        return (this.#fullpathPosix = fpp);\n    }\n    /**\n     * Is the Path of an unknown type?\n     *\n     * Note that we might know *something* about it if there has been a previous\n     * filesystem operation, for example that it does not exist, or is not a\n     * link, or whether it has child entries.\n     */\n    isUnknown() {\n        return (this.#type & IFMT) === UNKNOWN;\n    }\n    isType(type) {\n        return this[`is${type}`]();\n    }\n    getType() {\n        return (this.isUnknown() ? 'Unknown'\n            : this.isDirectory() ? 'Directory'\n                : this.isFile() ? 'File'\n                    : this.isSymbolicLink() ? 'SymbolicLink'\n                        : this.isFIFO() ? 'FIFO'\n                            : this.isCharacterDevice() ? 'CharacterDevice'\n                                : this.isBlockDevice() ? 'BlockDevice'\n                                    : /* c8 ignore start */ this.isSocket() ? 'Socket'\n                                        : 'Unknown');\n        /* c8 ignore stop */\n    }\n    /**\n     * Is the Path a regular file?\n     */\n    isFile() {\n        return (this.#type & IFMT) === IFREG;\n    }\n    /**\n     * Is the Path a directory?\n     */\n    isDirectory() {\n        return (this.#type & IFMT) === IFDIR;\n    }\n    /**\n     * Is the path a character device?\n     */\n    isCharacterDevice() {\n        return (this.#type & IFMT) === IFCHR;\n    }\n    /**\n     * Is the path a block device?\n     */\n    isBlockDevice() {\n        return (this.#type & IFMT) === IFBLK;\n    }\n    /**\n     * Is the path a FIFO pipe?\n     */\n    isFIFO() {\n        return (this.#type & IFMT) === IFIFO;\n    }\n    /**\n     * Is the path a socket?\n     */\n    isSocket() {\n        return (this.#type & IFMT) === IFSOCK;\n    }\n    /**\n     * Is the path a symbolic link?\n     */\n    isSymbolicLink() {\n        return (this.#type & IFLNK) === IFLNK;\n    }\n    /**\n     * Return the entry if it has been subject of a successful lstat, or\n     * undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* simply\n     * mean that we haven't called lstat on it.\n     */\n    lstatCached() {\n        return this.#type & LSTAT_CALLED ? this : undefined;\n    }\n    /**\n     * Return the cached link target if the entry has been the subject of a\n     * successful readlink, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readlink() has been called at some point.\n     */\n    readlinkCached() {\n        return this.#linkTarget;\n    }\n    /**\n     * Returns the cached realpath target if the entry has been the subject\n     * of a successful realpath, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * realpath() has been called at some point.\n     */\n    realpathCached() {\n        return this.#realpath;\n    }\n    /**\n     * Returns the cached child Path entries array if the entry has been the\n     * subject of a successful readdir(), or [] otherwise.\n     *\n     * Does not read the filesystem, so an empty array *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readdir() has been called recently enough to still be valid.\n     */\n    readdirCached() {\n        const children = this.children();\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n     * any indication that readlink will definitely fail.\n     *\n     * Returns false if the path is known to not be a symlink, if a previous\n     * readlink failed, or if the entry does not exist.\n     */\n    canReadlink() {\n        if (this.#linkTarget)\n            return true;\n        if (!this.parent)\n            return false;\n        // cases where it cannot possibly succeed\n        const ifmt = this.#type & IFMT;\n        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||\n            this.#type & ENOREADLINK ||\n            this.#type & ENOENT);\n    }\n    /**\n     * Return true if readdir has previously been successfully called on this\n     * path, indicating that cachedReaddir() is likely valid.\n     */\n    calledReaddir() {\n        return !!(this.#type & READDIR_CALLED);\n    }\n    /**\n     * Returns true if the path is known to not exist. That is, a previous lstat\n     * or readdir failed to verify its existence when that would have been\n     * expected, or a parent entry was marked either enoent or enotdir.\n     */\n    isENOENT() {\n        return !!(this.#type & ENOENT);\n    }\n    /**\n     * Return true if the path is a match for the given path name.  This handles\n     * case sensitivity and unicode normalization.\n     *\n     * Note: even on case-sensitive systems, it is **not** safe to test the\n     * equality of the `.name` property to determine whether a given pathname\n     * matches, due to unicode normalization mismatches.\n     *\n     * Always use this method instead of testing the `path.name` property\n     * directly.\n     */\n    isNamed(n) {\n        return !this.nocase ?\n            this.#matchName === normalize(n)\n            : this.#matchName === normalizeNocase(n);\n    }\n    /**\n     * Return the Path object corresponding to the target of a symbolic link.\n     *\n     * If the Path is not a symbolic link, or if the readlink call fails for any\n     * reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     */\n    async readlink() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */\n        // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */\n        try {\n            const read = await this.#fs.promises.readlink(this.fullpath());\n            const linkTarget = (await this.parent.realpath())?.resolve(read);\n            if (linkTarget) {\n                return (this.#linkTarget = linkTarget);\n            }\n        }\n        catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    /**\n     * Synchronous {@link PathBase.readlink}\n     */\n    readlinkSync() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */\n        // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */\n        try {\n            const read = this.#fs.readlinkSync(this.fullpath());\n            const linkTarget = this.parent.realpathSync()?.resolve(read);\n            if (linkTarget) {\n                return (this.#linkTarget = linkTarget);\n            }\n        }\n        catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    #readdirSuccess(children) {\n        // succeeded, mark readdir called bit\n        this.#type |= READDIR_CALLED;\n        // mark all remaining provisional children as ENOENT\n        for (let p = children.provisional; p < children.length; p++) {\n            const c = children[p];\n            if (c)\n                c.#markENOENT();\n        }\n    }\n    #markENOENT() {\n        // mark as UNKNOWN and ENOENT\n        if (this.#type & ENOENT)\n            return;\n        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;\n        this.#markChildrenENOENT();\n    }\n    #markChildrenENOENT() {\n        // all children are provisional and do not exist\n        const children = this.children();\n        children.provisional = 0;\n        for (const p of children) {\n            p.#markENOENT();\n        }\n    }\n    #markENOREALPATH() {\n        this.#type |= ENOREALPATH;\n        this.#markENOTDIR();\n    }\n    // save the information when we know the entry is not a dir\n    #markENOTDIR() {\n        // entry is not a directory, so any children can't exist.\n        // this *should* be impossible, since any children created\n        // after it's been marked ENOTDIR should be marked ENOENT,\n        // so it won't even get to this point.\n        /* c8 ignore start */\n        if (this.#type & ENOTDIR)\n            return;\n        /* c8 ignore stop */\n        let t = this.#type;\n        // this could happen if we stat a dir, then delete it,\n        // then try to read it or one of its children.\n        if ((t & IFMT) === IFDIR)\n            t &= IFMT_UNKNOWN;\n        this.#type = t | ENOTDIR;\n        this.#markChildrenENOENT();\n    }\n    #readdirFail(code = '') {\n        // markENOTDIR and markENOENT also set provisional=0\n        if (code === 'ENOTDIR' || code === 'EPERM') {\n            this.#markENOTDIR();\n        }\n        else if (code === 'ENOENT') {\n            this.#markENOENT();\n        }\n        else {\n            this.children().provisional = 0;\n        }\n    }\n    #lstatFail(code = '') {\n        // Windows just raises ENOENT in this case, disable for win CI\n        /* c8 ignore start */\n        if (code === 'ENOTDIR') {\n            // already know it has a parent by this point\n            const p = this.parent;\n            p.#markENOTDIR();\n        }\n        else if (code === 'ENOENT') {\n            /* c8 ignore stop */\n            this.#markENOENT();\n        }\n    }\n    #readlinkFail(code = '') {\n        let ter = this.#type;\n        ter |= ENOREADLINK;\n        if (code === 'ENOENT')\n            ter |= ENOENT;\n        // windows gets a weird error when you try to readlink a file\n        if (code === 'EINVAL' || code === 'UNKNOWN') {\n            // exists, but not a symlink, we don't know WHAT it is, so remove\n            // all IFMT bits.\n            ter &= IFMT_UNKNOWN;\n        }\n        this.#type = ter;\n        // windows just gets ENOENT in this case.  We do cover the case,\n        // just disabled because it's impossible on Windows CI\n        /* c8 ignore start */\n        if (code === 'ENOTDIR' && this.parent) {\n            this.parent.#markENOTDIR();\n        }\n        /* c8 ignore stop */\n    }\n    #readdirAddChild(e, c) {\n        return (this.#readdirMaybePromoteChild(e, c) ||\n            this.#readdirAddNewChild(e, c));\n    }\n    #readdirAddNewChild(e, c) {\n        // alloc new entry at head, so it's never provisional\n        const type = entToType(e);\n        const child = this.newChild(e.name, type, { parent: this });\n        const ifmt = child.#type & IFMT;\n        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n            child.#type |= ENOTDIR;\n        }\n        c.unshift(child);\n        c.provisional++;\n        return child;\n    }\n    #readdirMaybePromoteChild(e, c) {\n        for (let p = c.provisional; p < c.length; p++) {\n            const pchild = c[p];\n            const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);\n            if (name !== pchild.#matchName) {\n                continue;\n            }\n            return this.#readdirPromoteChild(e, pchild, p, c);\n        }\n    }\n    #readdirPromoteChild(e, p, index, c) {\n        const v = p.name;\n        // retain any other flags, but set ifmt from dirent\n        p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e);\n        // case sensitivity fixing when we learn the true name.\n        if (v !== e.name)\n            p.name = e.name;\n        // just advance provisional index (potentially off the list),\n        // otherwise we have to splice/pop it out and re-insert at head\n        if (index !== c.provisional) {\n            if (index === c.length - 1)\n                c.pop();\n            else\n                c.splice(index, 1);\n            c.unshift(p);\n        }\n        c.provisional++;\n        return p;\n    }\n    /**\n     * Call lstat() on this Path, and update all known information that can be\n     * determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async lstat() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));\n                return this;\n            }\n            catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    /**\n     * synchronous {@link PathBase.lstat}\n     */\n    lstatSync() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(this.#fs.lstatSync(this.fullpath()));\n                return this;\n            }\n            catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    #applyStat(st) {\n        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;\n        this.#atime = atime;\n        this.#atimeMs = atimeMs;\n        this.#birthtime = birthtime;\n        this.#birthtimeMs = birthtimeMs;\n        this.#blksize = blksize;\n        this.#blocks = blocks;\n        this.#ctime = ctime;\n        this.#ctimeMs = ctimeMs;\n        this.#dev = dev;\n        this.#gid = gid;\n        this.#ino = ino;\n        this.#mode = mode;\n        this.#mtime = mtime;\n        this.#mtimeMs = mtimeMs;\n        this.#nlink = nlink;\n        this.#rdev = rdev;\n        this.#size = size;\n        this.#uid = uid;\n        const ifmt = entToType(st);\n        // retain any other flags, but set the ifmt\n        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;\n        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n            this.#type |= ENOTDIR;\n        }\n    }\n    #onReaddirCB = [];\n    #readdirCBInFlight = false;\n    #callOnReaddirCB(children) {\n        this.#readdirCBInFlight = false;\n        const cbs = this.#onReaddirCB.slice();\n        this.#onReaddirCB.length = 0;\n        cbs.forEach(cb => cb(null, children));\n    }\n    /**\n     * Standard node-style callback interface to get list of directory entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     *\n     * @param cb The callback called with (er, entries).  Note that the `er`\n     * param is somewhat extraneous, as all readdir() errors are handled and\n     * simply result in an empty set of entries being returned.\n     * @param allowZalgo Boolean indicating that immediately known results should\n     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n     * zalgo at your peril, the dark pony lord is devious and unforgiving.\n     */\n    readdirCB(cb, allowZalgo = false) {\n        if (!this.canReaddir()) {\n            if (allowZalgo)\n                cb(null, []);\n            else\n                queueMicrotask(() => cb(null, []));\n            return;\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            const c = children.slice(0, children.provisional);\n            if (allowZalgo)\n                cb(null, c);\n            else\n                queueMicrotask(() => cb(null, c));\n            return;\n        }\n        // don't have to worry about zalgo at this point.\n        this.#onReaddirCB.push(cb);\n        if (this.#readdirCBInFlight) {\n            return;\n        }\n        this.#readdirCBInFlight = true;\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {\n            if (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            }\n            else {\n                // if we didn't get an error, we always get entries.\n                //@ts-ignore\n                for (const e of entries) {\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            }\n            this.#callOnReaddirCB(children.slice(0, children.provisional));\n            return;\n        });\n    }\n    #asyncReaddirInFlight;\n    /**\n     * Return an array of known child entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async readdir() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        if (this.#asyncReaddirInFlight) {\n            await this.#asyncReaddirInFlight;\n        }\n        else {\n            /* c8 ignore start */\n            let resolve = () => { };\n            /* c8 ignore stop */\n            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));\n            try {\n                for (const e of await this.#fs.promises.readdir(fullpath, {\n                    withFileTypes: true,\n                })) {\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            }\n            catch (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            }\n            this.#asyncReaddirInFlight = undefined;\n            resolve();\n        }\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * synchronous {@link PathBase.readdir}\n     */\n    readdirSync() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        try {\n            for (const e of this.#fs.readdirSync(fullpath, {\n                withFileTypes: true,\n            })) {\n                this.#readdirAddChild(e, children);\n            }\n            this.#readdirSuccess(children);\n        }\n        catch (er) {\n            this.#readdirFail(er.code);\n            children.provisional = 0;\n        }\n        return children.slice(0, children.provisional);\n    }\n    canReaddir() {\n        if (this.#type & ENOCHILD)\n            return false;\n        const ifmt = IFMT & this.#type;\n        // we always set ENOTDIR when setting IFMT, so should be impossible\n        /* c8 ignore start */\n        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n            return false;\n        }\n        /* c8 ignore stop */\n        return true;\n    }\n    shouldWalk(dirs, walkFilter) {\n        return ((this.#type & IFDIR) === IFDIR &&\n            !(this.#type & ENOCHILD) &&\n            !dirs.has(this) &&\n            (!walkFilter || walkFilter(this)));\n    }\n    /**\n     * Return the Path object corresponding to path as resolved\n     * by realpath(3).\n     *\n     * If the realpath call fails for any reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     * On success, returns a Path object.\n     */\n    async realpath() {\n        if (this.#realpath)\n            return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)\n            return undefined;\n        try {\n            const rp = await this.#fs.promises.realpath(this.fullpath());\n            return (this.#realpath = this.resolve(rp));\n        }\n        catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Synchronous {@link realpath}\n     */\n    realpathSync() {\n        if (this.#realpath)\n            return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)\n            return undefined;\n        try {\n            const rp = this.#fs.realpathSync(this.fullpath());\n            return (this.#realpath = this.resolve(rp));\n        }\n        catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Internal method to mark this Path object as the scurry cwd,\n     * called by {@link PathScurry#chdir}\n     *\n     * @internal\n     */\n    [setAsCwd](oldCwd) {\n        if (oldCwd === this)\n            return;\n        oldCwd.isCWD = false;\n        this.isCWD = true;\n        const changed = new Set([]);\n        let rp = [];\n        let p = this;\n        while (p && p.parent) {\n            changed.add(p);\n            p.#relative = rp.join(this.sep);\n            p.#relativePosix = rp.join('/');\n            p = p.parent;\n            rp.push('..');\n        }\n        // now un-memoize parents of old cwd\n        p = oldCwd;\n        while (p && p.parent && !changed.has(p)) {\n            p.#relative = undefined;\n            p.#relativePosix = undefined;\n            p = p.parent;\n        }\n    }\n}\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nexport class PathWin32 extends PathBase {\n    /**\n     * Separator for generating path strings.\n     */\n    sep = '\\\\';\n    /**\n     * Separator for parsing path strings.\n     */\n    splitSep = eitherSep;\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        super(name, type, root, roots, nocase, children, opts);\n    }\n    /**\n     * @internal\n     */\n    newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n    /**\n     * @internal\n     */\n    getRootString(path) {\n        return win32.parse(path).root;\n    }\n    /**\n     * @internal\n     */\n    getRoot(rootPath) {\n        rootPath = uncToDrive(rootPath.toUpperCase());\n        if (rootPath === this.root.name) {\n            return this.root;\n        }\n        // ok, not that one, check if it matches another we know about\n        for (const [compare, root] of Object.entries(this.roots)) {\n            if (this.sameRoot(rootPath, compare)) {\n                return (this.roots[rootPath] = root);\n            }\n        }\n        // otherwise, have to create a new one.\n        return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);\n    }\n    /**\n     * @internal\n     */\n    sameRoot(rootPath, compare = this.root.name) {\n        // windows can (rarely) have case-sensitive filesystem, but\n        // UNC and drive letters are always case-insensitive, and canonically\n        // represented uppercase.\n        rootPath = rootPath\n            .toUpperCase()\n            .replace(/\\//g, '\\\\')\n            .replace(uncDriveRegexp, '$1\\\\');\n        return rootPath === compare;\n    }\n}\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nexport class PathPosix extends PathBase {\n    /**\n     * separator for parsing path strings\n     */\n    splitSep = '/';\n    /**\n     * separator for generating path strings\n     */\n    sep = '/';\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        super(name, type, root, roots, nocase, children, opts);\n    }\n    /**\n     * @internal\n     */\n    getRootString(path) {\n        return path.startsWith('/') ? '/' : '';\n    }\n    /**\n     * @internal\n     */\n    getRoot(_rootPath) {\n        return this.root;\n    }\n    /**\n     * @internal\n     */\n    newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n}\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nexport class PathScurryBase {\n    /**\n     * The root Path entry for the current working directory of this Scurry\n     */\n    root;\n    /**\n     * The string path for the root of this Scurry's current working directory\n     */\n    rootPath;\n    /**\n     * A collection of all roots encountered, referenced by rootPath\n     */\n    roots;\n    /**\n     * The Path entry corresponding to this PathScurry's current working directory.\n     */\n    cwd;\n    #resolveCache;\n    #resolvePosixCache;\n    #children;\n    /**\n     * Perform path comparisons case-insensitively.\n     *\n     * Defaults true on Darwin and Windows systems, false elsewhere.\n     */\n    nocase;\n    #fs;\n    /**\n     * This class should not be instantiated directly.\n     *\n     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n     *\n     * @internal\n     */\n    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS, } = {}) {\n        this.#fs = fsFromOption(fs);\n        if (cwd instanceof URL || cwd.startsWith('file://')) {\n            cwd = fileURLToPath(cwd);\n        }\n        // resolve and split root, and then add to the store.\n        // this is the only time we call path.resolve()\n        const cwdPath = pathImpl.resolve(cwd);\n        this.roots = Object.create(null);\n        this.rootPath = this.parseRootPath(cwdPath);\n        this.#resolveCache = new ResolveCache();\n        this.#resolvePosixCache = new ResolveCache();\n        this.#children = new ChildrenCache(childrenCacheSize);\n        const split = cwdPath.substring(this.rootPath.length).split(sep);\n        // resolve('/') leaves '', splits to [''], we don't want that.\n        if (split.length === 1 && !split[0]) {\n            split.pop();\n        }\n        /* c8 ignore start */\n        if (nocase === undefined) {\n            throw new TypeError('must provide nocase setting to PathScurryBase ctor');\n        }\n        /* c8 ignore stop */\n        this.nocase = nocase;\n        this.root = this.newRoot(this.#fs);\n        this.roots[this.rootPath] = this.root;\n        let prev = this.root;\n        let len = split.length - 1;\n        const joinSep = pathImpl.sep;\n        let abs = this.rootPath;\n        let sawFirst = false;\n        for (const part of split) {\n            const l = len--;\n            prev = prev.child(part, {\n                relative: new Array(l).fill('..').join(joinSep),\n                relativePosix: new Array(l).fill('..').join('/'),\n                fullpath: (abs += (sawFirst ? '' : joinSep) + part),\n            });\n            sawFirst = true;\n        }\n        this.cwd = prev;\n    }\n    /**\n     * Get the depth of a provided path, string, or the cwd\n     */\n    depth(path = this.cwd) {\n        if (typeof path === 'string') {\n            path = this.cwd.resolve(path);\n        }\n        return path.depth();\n    }\n    /**\n     * Return the cache of child entries.  Exposed so subclasses can create\n     * child Path objects in a platform-specific way.\n     *\n     * @internal\n     */\n    childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */\n    resolve(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = '';\n        for (let i = paths.length - 1; i >= 0; i--) {\n            const p = paths[i];\n            if (!p || p === '.')\n                continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolveCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpath();\n        this.#resolveCache.set(r, result);\n        return result;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string, returning\n     * the posix path.  Identical to .resolve() on posix systems, but on\n     * windows will return a forward-slash separated UNC path.\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */\n    resolvePosix(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = '';\n        for (let i = paths.length - 1; i >= 0; i--) {\n            const p = paths[i];\n            if (!p || p === '.')\n                continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolvePosixCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpathPosix();\n        this.#resolvePosixCache.set(r, result);\n        return result;\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or entry\n     */\n    relative(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relative();\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or\n     * entry, using / as the path delimiter, even on Windows.\n     */\n    relativePosix(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relativePosix();\n    }\n    /**\n     * Return the basename for the provided string or Path object\n     */\n    basename(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.name;\n    }\n    /**\n     * Return the dirname for the provided string or Path object\n     */\n    dirname(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return (entry.parent || entry).fullpath();\n    }\n    async readdir(entry = this.cwd, opts = {\n        withFileTypes: true,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        }\n        else {\n            const p = await entry.readdir();\n            return withFileTypes ? p : p.map(e => e.name);\n        }\n    }\n    readdirSync(entry = this.cwd, opts = {\n        withFileTypes: true,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        }\n        else if (withFileTypes) {\n            return entry.readdirSync();\n        }\n        else {\n            return entry.readdirSync().map(e => e.name);\n        }\n    }\n    /**\n     * Call lstat() on the string or Path object, and update all known\n     * information that can be determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async lstat(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstat();\n    }\n    /**\n     * synchronous {@link PathScurryBase.lstat}\n     */\n    lstatSync(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstatSync();\n    }\n    async readlink(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.readlink();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    readlinkSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.readlinkSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async realpath(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.realpath();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    realpathSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.realpathSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async walk(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const walk = (dir, cb) => {\n            dirs.add(dir);\n            dir.readdirCB((er, entries) => {\n                /* c8 ignore start */\n                if (er) {\n                    return cb(er);\n                }\n                /* c8 ignore stop */\n                let len = entries.length;\n                if (!len)\n                    return cb();\n                const next = () => {\n                    if (--len === 0) {\n                        cb();\n                    }\n                };\n                for (const e of entries) {\n                    if (!filter || filter(e)) {\n                        results.push(withFileTypes ? e : e.fullpath());\n                    }\n                    if (follow && e.isSymbolicLink()) {\n                        e.realpath()\n                            .then(r => (r?.isUnknown() ? r.lstat() : r))\n                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());\n                    }\n                    else {\n                        if (e.shouldWalk(dirs, walkFilter)) {\n                            walk(e, next);\n                        }\n                        else {\n                            next();\n                        }\n                    }\n                }\n            }, true); // zalgooooooo\n        };\n        const start = entry;\n        return new Promise((res, rej) => {\n            walk(start, er => {\n                /* c8 ignore start */\n                if (er)\n                    return rej(er);\n                /* c8 ignore stop */\n                res(results);\n            });\n        });\n    }\n    walkSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set([entry]);\n        for (const dir of dirs) {\n            const entries = dir.readdirSync();\n            for (const e of entries) {\n                if (!filter || filter(e)) {\n                    results.push(withFileTypes ? e : e.fullpath());\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync())))\n                        continue;\n                    if (r.isUnknown())\n                        r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * Support for `for await`\n     *\n     * Alias for {@link PathScurryBase.iterate}\n     *\n     * Note: As of Node 19, this is very slow, compared to other methods of\n     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n     */\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    iterate(entry = this.cwd, options = {}) {\n        // iterating async over the stream is significantly more performant,\n        // especially in the warm-cache scenario, because it buffers up directory\n        // entries in the background instead of waiting for a yield for each one.\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            options = entry;\n            entry = this.cwd;\n        }\n        return this.stream(entry, options)[Symbol.asyncIterator]();\n    }\n    /**\n     * Iterating over a PathScurry performs a synchronous walk.\n     *\n     * Alias for {@link PathScurryBase.iterateSync}\n     */\n    [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    *iterateSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        if (!filter || filter(entry)) {\n            yield withFileTypes ? entry : entry.fullpath();\n        }\n        const dirs = new Set([entry]);\n        for (const dir of dirs) {\n            const entries = dir.readdirSync();\n            for (const e of entries) {\n                if (!filter || filter(e)) {\n                    yield withFileTypes ? e : e.fullpath();\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync())))\n                        continue;\n                    if (r.isUnknown())\n                        r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n    }\n    stream(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = new Minipass({ objectMode: true });\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const queue = [entry];\n        let processing = 0;\n        const process = () => {\n            let paused = false;\n            while (!paused) {\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0)\n                        results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const onReaddir = (er, entries, didRealpaths = false) => {\n                    /* c8 ignore start */\n                    if (er)\n                        return results.emit('error', er);\n                    /* c8 ignore stop */\n                    if (follow && !didRealpaths) {\n                        const promises = [];\n                        for (const e of entries) {\n                            if (e.isSymbolicLink()) {\n                                promises.push(e\n                                    .realpath()\n                                    .then((r) => r?.isUnknown() ? r.lstat() : r));\n                            }\n                        }\n                        if (promises.length) {\n                            Promise.all(promises).then(() => onReaddir(null, entries, true));\n                            return;\n                        }\n                    }\n                    for (const e of entries) {\n                        if (e && (!filter || filter(e))) {\n                            if (!results.write(withFileTypes ? e : e.fullpath())) {\n                                paused = true;\n                            }\n                        }\n                    }\n                    processing--;\n                    for (const e of entries) {\n                        const r = e.realpathCached() || e;\n                        if (r.shouldWalk(dirs, walkFilter)) {\n                            queue.push(r);\n                        }\n                    }\n                    if (paused && !results.flowing) {\n                        results.once('drain', process);\n                    }\n                    else if (!sync) {\n                        process();\n                    }\n                };\n                // zalgo containment\n                let sync = true;\n                dir.readdirCB(onReaddir, true);\n                sync = false;\n            }\n        };\n        process();\n        return results;\n    }\n    streamSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = new Minipass({ objectMode: true });\n        const dirs = new Set();\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const queue = [entry];\n        let processing = 0;\n        const process = () => {\n            let paused = false;\n            while (!paused) {\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0)\n                        results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const entries = dir.readdirSync();\n                for (const e of entries) {\n                    if (!filter || filter(e)) {\n                        if (!results.write(withFileTypes ? e : e.fullpath())) {\n                            paused = true;\n                        }\n                    }\n                }\n                processing--;\n                for (const e of entries) {\n                    let r = e;\n                    if (e.isSymbolicLink()) {\n                        if (!(follow && (r = e.realpathSync())))\n                            continue;\n                        if (r.isUnknown())\n                            r.lstatSync();\n                    }\n                    if (r.shouldWalk(dirs, walkFilter)) {\n                        queue.push(r);\n                    }\n                }\n            }\n            if (paused && !results.flowing)\n                results.once('drain', process);\n        };\n        process();\n        return results;\n    }\n    chdir(path = this.cwd) {\n        const oldCwd = this.cwd;\n        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;\n        this.cwd[setAsCwd](oldCwd);\n    }\n}\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nexport class PathScurryWin32 extends PathScurryBase {\n    /**\n     * separator for generating path strings\n     */\n    sep = '\\\\';\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = true } = opts;\n        super(cwd, win32, '\\\\', { ...opts, nocase });\n        this.nocase = nocase;\n        for (let p = this.cwd; p; p = p.parent) {\n            p.nocase = this.nocase;\n        }\n    }\n    /**\n     * @internal\n     */\n    parseRootPath(dir) {\n        // if the path starts with a single separator, it's not a UNC, and we'll\n        // just get separator as the root, and driveFromUNC will return \\\n        // In that case, mount \\ on the root from the cwd.\n        return win32.parse(dir).root.toUpperCase();\n    }\n    /**\n     * @internal\n     */\n    newRoot(fs) {\n        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */\n    isAbsolute(p) {\n        return (p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p));\n    }\n}\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryPosix extends PathScurryBase {\n    /**\n     * separator for generating path strings\n     */\n    sep = '/';\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = false } = opts;\n        super(cwd, posix, '/', { ...opts, nocase });\n        this.nocase = nocase;\n    }\n    /**\n     * @internal\n     */\n    parseRootPath(_dir) {\n        return '/';\n    }\n    /**\n     * @internal\n     */\n    newRoot(fs) {\n        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */\n    isAbsolute(p) {\n        return p.startsWith('/');\n    }\n}\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryDarwin extends PathScurryPosix {\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = true } = opts;\n        super(cwd, { ...opts, nocase });\n    }\n}\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexport const Path = process.platform === 'win32' ? PathWin32 : PathPosix;\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexport const PathScurry = process.platform === 'win32' ? PathScurryWin32\n    : process.platform === 'darwin' ? PathScurryDarwin\n        : PathScurryPosix;\n//# sourceMappingURL=index.js.map",
    "const proc = typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n    };\nimport { EventEmitter } from 'node:events';\nimport Stream from 'node:stream';\nimport { StringDecoder } from 'node:string_decoder';\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nexport const isStream = (s) => !!s &&\n    typeof s === 'object' &&\n    (s instanceof Minipass ||\n        s instanceof Stream ||\n        isReadable(s) ||\n        isWritable(s));\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nexport const isReadable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof EventEmitter &&\n    typeof s.pipe === 'function' &&\n    // node core Writable streams have a pipe() method, but it throws\n    s.pipe !== Stream.Writable.prototype.pipe;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nexport const isWritable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof EventEmitter &&\n    typeof s.write === 'function' &&\n    typeof s.end === 'function';\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed');\n// internal event when stream has an error\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\nconst DATALISTENERS = Symbol('dataListeners');\nconst DISCARDED = Symbol('discarded');\nconst defer = (fn) => Promise.resolve().then(fn);\nconst nodefer = (fn) => fn();\nconst isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBufferLike = (b) => b instanceof ArrayBuffer ||\n    (!!b &&\n        typeof b === 'object' &&\n        b.constructor &&\n        b.constructor.name === 'ArrayBuffer' &&\n        b.byteLength >= 0);\nconst isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe {\n    src;\n    dest;\n    opts;\n    ondrain;\n    constructor(src, dest, opts) {\n        this.src = src;\n        this.dest = dest;\n        this.opts = opts;\n        this.ondrain = () => src[RESUME]();\n        this.dest.on('drain', this.ondrain);\n    }\n    unpipe() {\n        this.dest.removeListener('drain', this.ondrain);\n    }\n    // only here for the prototype\n    /* c8 ignore start */\n    proxyErrors(_er) { }\n    /* c8 ignore stop */\n    end() {\n        this.unpipe();\n        if (this.opts.end)\n            this.dest.end();\n    }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors extends Pipe {\n    unpipe() {\n        this.src.removeListener('error', this.proxyErrors);\n        super.unpipe();\n    }\n    constructor(src, dest, opts) {\n        super(src, dest, opts);\n        this.proxyErrors = er => dest.emit('error', er);\n        src.on('error', this.proxyErrors);\n    }\n}\nconst isObjectModeOptions = (o) => !!o.objectMode;\nconst isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nexport class Minipass extends EventEmitter {\n    [FLOWING] = false;\n    [PAUSED] = false;\n    [PIPES] = [];\n    [BUFFER] = [];\n    [OBJECTMODE];\n    [ENCODING];\n    [ASYNC];\n    [DECODER];\n    [EOF] = false;\n    [EMITTED_END] = false;\n    [EMITTING_END] = false;\n    [CLOSED] = false;\n    [EMITTED_ERROR] = null;\n    [BUFFERLENGTH] = 0;\n    [DESTROYED] = false;\n    [SIGNAL];\n    [ABORTED] = false;\n    [DATALISTENERS] = 0;\n    [DISCARDED] = false;\n    /**\n     * true if the stream can be written\n     */\n    writable = true;\n    /**\n     * true if the stream can be read\n     */\n    readable = true;\n    /**\n     * If `RType` is Buffer, then options do not need to be provided.\n     * Otherwise, an options object must be provided to specify either\n     * {@link Minipass.SharedOptions.objectMode} or\n     * {@link Minipass.SharedOptions.encoding}, as appropriate.\n     */\n    constructor(...args) {\n        const options = (args[0] ||\n            {});\n        super();\n        if (options.objectMode && typeof options.encoding === 'string') {\n            throw new TypeError('Encoding and objectMode may not be used together');\n        }\n        if (isObjectModeOptions(options)) {\n            this[OBJECTMODE] = true;\n            this[ENCODING] = null;\n        }\n        else if (isEncodingOptions(options)) {\n            this[ENCODING] = options.encoding;\n            this[OBJECTMODE] = false;\n        }\n        else {\n            this[OBJECTMODE] = false;\n            this[ENCODING] = null;\n        }\n        this[ASYNC] = !!options.async;\n        this[DECODER] = this[ENCODING]\n            ? new StringDecoder(this[ENCODING])\n            : null;\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposeBuffer === true) {\n            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });\n        }\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposePipes === true) {\n            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });\n        }\n        const { signal } = options;\n        if (signal) {\n            this[SIGNAL] = signal;\n            if (signal.aborted) {\n                this[ABORT]();\n            }\n            else {\n                signal.addEventListener('abort', () => this[ABORT]());\n            }\n        }\n    }\n    /**\n     * The amount of data stored in the buffer waiting to be read.\n     *\n     * For Buffer strings, this will be the total byte length.\n     * For string encoding streams, this will be the string character length,\n     * according to JavaScript's `string.length` logic.\n     * For objectMode streams, this is a count of the items waiting to be\n     * emitted.\n     */\n    get bufferLength() {\n        return this[BUFFERLENGTH];\n    }\n    /**\n     * The `BufferEncoding` currently in use, or `null`\n     */\n    get encoding() {\n        return this[ENCODING];\n    }\n    /**\n     * @deprecated - This is a read only property\n     */\n    set encoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * @deprecated - Encoding may only be set at instantiation time\n     */\n    setEncoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * True if this is an objectMode stream\n     */\n    get objectMode() {\n        return this[OBJECTMODE];\n    }\n    /**\n     * @deprecated - This is a read-only property\n     */\n    set objectMode(_om) {\n        throw new Error('objectMode must be set at instantiation time');\n    }\n    /**\n     * true if this is an async stream\n     */\n    get ['async']() {\n        return this[ASYNC];\n    }\n    /**\n     * Set to true to make this stream async.\n     *\n     * Once set, it cannot be unset, as this would potentially cause incorrect\n     * behavior.  Ie, a sync stream can be made async, but an async stream\n     * cannot be safely made sync.\n     */\n    set ['async'](a) {\n        this[ASYNC] = this[ASYNC] || !!a;\n    }\n    // drop everything and get out of the flow completely\n    [ABORT]() {\n        this[ABORTED] = true;\n        this.emit('abort', this[SIGNAL]?.reason);\n        this.destroy(this[SIGNAL]?.reason);\n    }\n    /**\n     * True if the stream has been aborted.\n     */\n    get aborted() {\n        return this[ABORTED];\n    }\n    /**\n     * No-op setter. Stream aborted status is set via the AbortSignal provided\n     * in the constructor options.\n     */\n    set aborted(_) { }\n    write(chunk, encoding, cb) {\n        if (this[ABORTED])\n            return false;\n        if (this[EOF])\n            throw new Error('write after end');\n        if (this[DESTROYED]) {\n            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));\n            return true;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (!encoding)\n            encoding = 'utf8';\n        const fn = this[ASYNC] ? defer : nodefer;\n        // convert array buffers and typed array views into buffers\n        // at some point in the future, we may want to do the opposite!\n        // leave strings and buffers as-is\n        // anything is only allowed if in object mode, so throw\n        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n            if (isArrayBufferView(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n            }\n            else if (isArrayBufferLike(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk);\n            }\n            else if (typeof chunk !== 'string') {\n                throw new Error('Non-contiguous data written to non-objectMode stream');\n            }\n        }\n        // handle object mode up front, since it's simpler\n        // this yields better performance, fewer checks later.\n        if (this[OBJECTMODE]) {\n            // maybe impossible?\n            /* c8 ignore start */\n            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n                this[FLUSH](true);\n            /* c8 ignore stop */\n            if (this[FLOWING])\n                this.emit('data', chunk);\n            else\n                this[BUFFERPUSH](chunk);\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // at this point the chunk is a buffer or string\n        // don't buffer it up or send it to the decoder\n        if (!chunk.length) {\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // fast-path writing strings of same encoding to a stream with\n        // an empty buffer, skipping the buffer/decoder dance\n        if (typeof chunk === 'string' &&\n            // unless it is a string already ready for us to use\n            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = this[DECODER].write(chunk);\n        }\n        // Note: flushing CAN potentially switch us into not-flowing mode\n        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n            this[FLUSH](true);\n        if (this[FLOWING])\n            this.emit('data', chunk);\n        else\n            this[BUFFERPUSH](chunk);\n        if (this[BUFFERLENGTH] !== 0)\n            this.emit('readable');\n        if (cb)\n            fn(cb);\n        return this[FLOWING];\n    }\n    /**\n     * Low-level explicit read method.\n     *\n     * In objectMode, the argument is ignored, and one item is returned if\n     * available.\n     *\n     * `n` is the number of bytes (or in the case of encoding streams,\n     * characters) to consume. If `n` is not provided, then the entire buffer\n     * is returned, or `null` is returned if no data is available.\n     *\n     * If `n` is greater that the amount of data in the internal buffer,\n     * then `null` is returned.\n     */\n    read(n) {\n        if (this[DESTROYED])\n            return null;\n        this[DISCARDED] = false;\n        if (this[BUFFERLENGTH] === 0 ||\n            n === 0 ||\n            (n && n > this[BUFFERLENGTH])) {\n            this[MAYBE_EMIT_END]();\n            return null;\n        }\n        if (this[OBJECTMODE])\n            n = null;\n        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n            // not object mode, so if we have an encoding, then RType is string\n            // otherwise, must be Buffer\n            this[BUFFER] = [\n                (this[ENCODING]\n                    ? this[BUFFER].join('')\n                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),\n            ];\n        }\n        const ret = this[READ](n || null, this[BUFFER][0]);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [READ](n, chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERSHIFT]();\n        else {\n            const c = chunk;\n            if (n === c.length || n === null)\n                this[BUFFERSHIFT]();\n            else if (typeof c === 'string') {\n                this[BUFFER][0] = c.slice(n);\n                chunk = c.slice(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n            else {\n                this[BUFFER][0] = c.subarray(n);\n                chunk = c.subarray(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n        }\n        this.emit('data', chunk);\n        if (!this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n        return chunk;\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (chunk !== undefined)\n            this.write(chunk, encoding);\n        if (cb)\n            this.once('end', cb);\n        this[EOF] = true;\n        this.writable = false;\n        // if we haven't written anything, then go ahead and emit,\n        // even if we're not reading.\n        // we'll re-emit if a new 'end' listener is added anyway.\n        // This makes MP more suitable to write-only use cases.\n        if (this[FLOWING] || !this[PAUSED])\n            this[MAYBE_EMIT_END]();\n        return this;\n    }\n    // don't let the internal resume be overwritten\n    [RESUME]() {\n        if (this[DESTROYED])\n            return;\n        if (!this[DATALISTENERS] && !this[PIPES].length) {\n            this[DISCARDED] = true;\n        }\n        this[PAUSED] = false;\n        this[FLOWING] = true;\n        this.emit('resume');\n        if (this[BUFFER].length)\n            this[FLUSH]();\n        else if (this[EOF])\n            this[MAYBE_EMIT_END]();\n        else\n            this.emit('drain');\n    }\n    /**\n     * Resume the stream if it is currently in a paused state\n     *\n     * If called when there are no pipe destinations or `data` event listeners,\n     * this will place the stream in a \"discarded\" state, where all data will\n     * be thrown away. The discarded state is removed if a pipe destination or\n     * data handler is added, if pause() is called, or if any synchronous or\n     * asynchronous iteration is started.\n     */\n    resume() {\n        return this[RESUME]();\n    }\n    /**\n     * Pause the stream\n     */\n    pause() {\n        this[FLOWING] = false;\n        this[PAUSED] = true;\n        this[DISCARDED] = false;\n    }\n    /**\n     * true if the stream has been forcibly destroyed\n     */\n    get destroyed() {\n        return this[DESTROYED];\n    }\n    /**\n     * true if the stream is currently in a flowing state, meaning that\n     * any writes will be immediately emitted.\n     */\n    get flowing() {\n        return this[FLOWING];\n    }\n    /**\n     * true if the stream is currently in a paused state\n     */\n    get paused() {\n        return this[PAUSED];\n    }\n    [BUFFERPUSH](chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] += 1;\n        else\n            this[BUFFERLENGTH] += chunk.length;\n        this[BUFFER].push(chunk);\n    }\n    [BUFFERSHIFT]() {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] -= 1;\n        else\n            this[BUFFERLENGTH] -= this[BUFFER][0].length;\n        return this[BUFFER].shift();\n    }\n    [FLUSH](noDrain = false) {\n        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n            this[BUFFER].length);\n        if (!noDrain && !this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n    }\n    [FLUSHCHUNK](chunk) {\n        this.emit('data', chunk);\n        return this[FLOWING];\n    }\n    /**\n     * Pipe all data emitted by this stream into the destination provided.\n     *\n     * Triggers the flow of data.\n     */\n    pipe(dest, opts) {\n        if (this[DESTROYED])\n            return dest;\n        this[DISCARDED] = false;\n        const ended = this[EMITTED_END];\n        opts = opts || {};\n        if (dest === proc.stdout || dest === proc.stderr)\n            opts.end = false;\n        else\n            opts.end = opts.end !== false;\n        opts.proxyErrors = !!opts.proxyErrors;\n        // piping an ended stream ends immediately\n        if (ended) {\n            if (opts.end)\n                dest.end();\n        }\n        else {\n            // \"as\" here just ignores the WType, which pipes don't care about,\n            // since they're only consuming from us, and writing to the dest\n            this[PIPES].push(!opts.proxyErrors\n                ? new Pipe(this, dest, opts)\n                : new PipeProxyErrors(this, dest, opts));\n            if (this[ASYNC])\n                defer(() => this[RESUME]());\n            else\n                this[RESUME]();\n        }\n        return dest;\n    }\n    /**\n     * Fully unhook a piped destination stream.\n     *\n     * If the destination stream was the only consumer of this stream (ie,\n     * there are no other piped destinations or `'data'` event listeners)\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    unpipe(dest) {\n        const p = this[PIPES].find(p => p.dest === dest);\n        if (p) {\n            if (this[PIPES].length === 1) {\n                if (this[FLOWING] && this[DATALISTENERS] === 0) {\n                    this[FLOWING] = false;\n                }\n                this[PIPES] = [];\n            }\n            else\n                this[PIPES].splice(this[PIPES].indexOf(p), 1);\n            p.unpipe();\n        }\n    }\n    /**\n     * Alias for {@link Minipass#on}\n     */\n    addListener(ev, handler) {\n        return this.on(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.on`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * - Adding a 'data' event handler will trigger the flow of data\n     *\n     * - Adding a 'readable' event handler when there is data waiting to be read\n     *   will cause 'readable' to be emitted immediately.\n     *\n     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n     *   already passed will cause the event to be emitted immediately and all\n     *   handlers removed.\n     *\n     * - Adding an 'error' event handler after an error has been emitted will\n     *   cause the event to be re-emitted immediately with the error previously\n     *   raised.\n     */\n    on(ev, handler) {\n        const ret = super.on(ev, handler);\n        if (ev === 'data') {\n            this[DISCARDED] = false;\n            this[DATALISTENERS]++;\n            if (!this[PIPES].length && !this[FLOWING]) {\n                this[RESUME]();\n            }\n        }\n        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n            super.emit('readable');\n        }\n        else if (isEndish(ev) && this[EMITTED_END]) {\n            super.emit(ev);\n            this.removeAllListeners(ev);\n        }\n        else if (ev === 'error' && this[EMITTED_ERROR]) {\n            const h = handler;\n            if (this[ASYNC])\n                defer(() => h.call(this, this[EMITTED_ERROR]));\n            else\n                h.call(this, this[EMITTED_ERROR]);\n        }\n        return ret;\n    }\n    /**\n     * Alias for {@link Minipass#off}\n     */\n    removeListener(ev, handler) {\n        return this.off(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.off`\n     *\n     * If a 'data' event handler is removed, and it was the last consumer\n     * (ie, there are no pipe destinations or other 'data' event listeners),\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    off(ev, handler) {\n        const ret = super.off(ev, handler);\n        // if we previously had listeners, and now we don't, and we don't\n        // have any pipes, then stop the flow, unless it's been explicitly\n        // put in a discarded flowing state via stream.resume().\n        if (ev === 'data') {\n            this[DATALISTENERS] = this.listeners('data').length;\n            if (this[DATALISTENERS] === 0 &&\n                !this[DISCARDED] &&\n                !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Mostly identical to `EventEmitter.removeAllListeners`\n     *\n     * If all 'data' event handlers are removed, and they were the last consumer\n     * (ie, there are no pipe destinations), then the flow of data will stop\n     * until there is another consumer or {@link Minipass#resume} is explicitly\n     * called.\n     */\n    removeAllListeners(ev) {\n        const ret = super.removeAllListeners(ev);\n        if (ev === 'data' || ev === undefined) {\n            this[DATALISTENERS] = 0;\n            if (!this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * true if the 'end' event has been emitted\n     */\n    get emittedEnd() {\n        return this[EMITTED_END];\n    }\n    [MAYBE_EMIT_END]() {\n        if (!this[EMITTING_END] &&\n            !this[EMITTED_END] &&\n            !this[DESTROYED] &&\n            this[BUFFER].length === 0 &&\n            this[EOF]) {\n            this[EMITTING_END] = true;\n            this.emit('end');\n            this.emit('prefinish');\n            this.emit('finish');\n            if (this[CLOSED])\n                this.emit('close');\n            this[EMITTING_END] = false;\n        }\n    }\n    /**\n     * Mostly identical to `EventEmitter.emit`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * If the stream has been destroyed, and the event is something other\n     * than 'close' or 'error', then `false` is returned and no handlers\n     * are called.\n     *\n     * If the event is 'end', and has already been emitted, then the event\n     * is ignored. If the stream is in a paused or non-flowing state, then\n     * the event will be deferred until data flow resumes. If the stream is\n     * async, then handlers will be called on the next tick rather than\n     * immediately.\n     *\n     * If the event is 'close', and 'end' has not yet been emitted, then\n     * the event will be deferred until after 'end' is emitted.\n     *\n     * If the event is 'error', and an AbortSignal was provided for the stream,\n     * and there are no listeners, then the event is ignored, matching the\n     * behavior of node core streams in the presense of an AbortSignal.\n     *\n     * If the event is 'finish' or 'prefinish', then all listeners will be\n     * removed after emitting the event, to prevent double-firing.\n     */\n    emit(ev, ...args) {\n        const data = args[0];\n        // error and close are only events allowed after calling destroy()\n        if (ev !== 'error' &&\n            ev !== 'close' &&\n            ev !== DESTROYED &&\n            this[DESTROYED]) {\n            return false;\n        }\n        else if (ev === 'data') {\n            return !this[OBJECTMODE] && !data\n                ? false\n                : this[ASYNC]\n                    ? (defer(() => this[EMITDATA](data)), true)\n                    : this[EMITDATA](data);\n        }\n        else if (ev === 'end') {\n            return this[EMITEND]();\n        }\n        else if (ev === 'close') {\n            this[CLOSED] = true;\n            // don't emit close before 'end' and 'finish'\n            if (!this[EMITTED_END] && !this[DESTROYED])\n                return false;\n            const ret = super.emit('close');\n            this.removeAllListeners('close');\n            return ret;\n        }\n        else if (ev === 'error') {\n            this[EMITTED_ERROR] = data;\n            super.emit(ERROR, data);\n            const ret = !this[SIGNAL] || this.listeners('error').length\n                ? super.emit('error', data)\n                : false;\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'resume') {\n            const ret = super.emit('resume');\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'finish' || ev === 'prefinish') {\n            const ret = super.emit(ev);\n            this.removeAllListeners(ev);\n            return ret;\n        }\n        // Some other unknown event\n        const ret = super.emit(ev, ...args);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITDATA](data) {\n        for (const p of this[PIPES]) {\n            if (p.dest.write(data) === false)\n                this.pause();\n        }\n        const ret = this[DISCARDED] ? false : super.emit('data', data);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITEND]() {\n        if (this[EMITTED_END])\n            return false;\n        this[EMITTED_END] = true;\n        this.readable = false;\n        return this[ASYNC]\n            ? (defer(() => this[EMITEND2]()), true)\n            : this[EMITEND2]();\n    }\n    [EMITEND2]() {\n        if (this[DECODER]) {\n            const data = this[DECODER].end();\n            if (data) {\n                for (const p of this[PIPES]) {\n                    p.dest.write(data);\n                }\n                if (!this[DISCARDED])\n                    super.emit('data', data);\n            }\n        }\n        for (const p of this[PIPES]) {\n            p.end();\n        }\n        const ret = super.emit('end');\n        this.removeAllListeners('end');\n        return ret;\n    }\n    /**\n     * Return a Promise that resolves to an array of all emitted data once\n     * the stream ends.\n     */\n    async collect() {\n        const buf = Object.assign([], {\n            dataLength: 0,\n        });\n        if (!this[OBJECTMODE])\n            buf.dataLength = 0;\n        // set the promise first, in case an error is raised\n        // by triggering the flow here.\n        const p = this.promise();\n        this.on('data', c => {\n            buf.push(c);\n            if (!this[OBJECTMODE])\n                buf.dataLength += c.length;\n        });\n        await p;\n        return buf;\n    }\n    /**\n     * Return a Promise that resolves to the concatenation of all emitted data\n     * once the stream ends.\n     *\n     * Not allowed on objectMode streams.\n     */\n    async concat() {\n        if (this[OBJECTMODE]) {\n            throw new Error('cannot concat in objectMode');\n        }\n        const buf = await this.collect();\n        return (this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength));\n    }\n    /**\n     * Return a void Promise that resolves once the stream ends.\n     */\n    async promise() {\n        return new Promise((resolve, reject) => {\n            this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n            this.on('error', er => reject(er));\n            this.on('end', () => resolve());\n        });\n    }\n    /**\n     * Asynchronous `for await of` iteration.\n     *\n     * This will continue emitting all chunks until the stream terminates.\n     */\n    [Symbol.asyncIterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = async () => {\n            this.pause();\n            stopped = true;\n            return { value: undefined, done: true };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const res = this.read();\n            if (res !== null)\n                return Promise.resolve({ done: false, value: res });\n            if (this[EOF])\n                return stop();\n            let resolve;\n            let reject;\n            const onerr = (er) => {\n                this.off('data', ondata);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                reject(er);\n            };\n            const ondata = (value) => {\n                this.off('error', onerr);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                this.pause();\n                resolve({ value, done: !!this[EOF] });\n            };\n            const onend = () => {\n                this.off('error', onerr);\n                this.off('data', ondata);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                resolve({ done: true, value: undefined });\n            };\n            const ondestroy = () => onerr(new Error('stream destroyed'));\n            return new Promise((res, rej) => {\n                reject = rej;\n                resolve = res;\n                this.once(DESTROYED, ondestroy);\n                this.once('error', onerr);\n                this.once('end', onend);\n                this.once('data', ondata);\n            });\n        };\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Synchronous `for of` iteration.\n     *\n     * The iteration will terminate when the internal buffer runs out, even\n     * if the stream has not yet terminated.\n     */\n    [Symbol.iterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = () => {\n            this.pause();\n            this.off(ERROR, stop);\n            this.off(DESTROYED, stop);\n            this.off('end', stop);\n            stopped = true;\n            return { done: true, value: undefined };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const value = this.read();\n            return value === null ? stop() : { done: false, value };\n        };\n        this.once('end', stop);\n        this.once(ERROR, stop);\n        this.once(DESTROYED, stop);\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Destroy a stream, preventing it from being used for any further purpose.\n     *\n     * If the stream has a `close()` method, then it will be called on\n     * destruction.\n     *\n     * After destruction, any attempt to write data, read data, or emit most\n     * events will be ignored.\n     *\n     * If an error argument is provided, then it will be emitted in an\n     * 'error' event.\n     */\n    destroy(er) {\n        if (this[DESTROYED]) {\n            if (er)\n                this.emit('error', er);\n            else\n                this.emit(DESTROYED);\n            return this;\n        }\n        this[DESTROYED] = true;\n        this[DISCARDED] = true;\n        // throw away all buffered data, it's never coming out\n        this[BUFFER].length = 0;\n        this[BUFFERLENGTH] = 0;\n        const wc = this;\n        if (typeof wc.close === 'function' && !this[CLOSED])\n            wc.close();\n        if (er)\n            this.emit('error', er);\n        // if no error to emit, still reject pending promises\n        else\n            this.emit(DESTROYED);\n        return this;\n    }\n    /**\n     * Alias for {@link isStream}\n     *\n     * Former export location, maintained for backwards compatibility.\n     *\n     * @deprecated\n     */\n    static get isStream() {\n        return isStream;\n    }\n}\n//# sourceMappingURL=index.js.map",
    "// this is just a very light wrapper around 2 arrays with an offset index\nimport { GLOBSTAR } from 'minimatch';\nconst isPatternList = (pl) => pl.length >= 1;\nconst isGlobList = (gl) => gl.length >= 1;\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */\nexport class Pattern {\n    #patternList;\n    #globList;\n    #index;\n    length;\n    #platform;\n    #rest;\n    #globString;\n    #isDrive;\n    #isUNC;\n    #isAbsolute;\n    #followGlobstar = true;\n    constructor(patternList, globList, index, platform) {\n        if (!isPatternList(patternList)) {\n            throw new TypeError('empty pattern list');\n        }\n        if (!isGlobList(globList)) {\n            throw new TypeError('empty glob list');\n        }\n        if (globList.length !== patternList.length) {\n            throw new TypeError('mismatched pattern list and glob list lengths');\n        }\n        this.length = patternList.length;\n        if (index < 0 || index >= this.length) {\n            throw new TypeError('index out of range');\n        }\n        this.#patternList = patternList;\n        this.#globList = globList;\n        this.#index = index;\n        this.#platform = platform;\n        // normalize root entries of absolute patterns on initial creation.\n        if (this.#index === 0) {\n            // c: => ['c:/']\n            // C:/ => ['C:/']\n            // C:/x => ['C:/', 'x']\n            // //host/share => ['//host/share/']\n            // //host/share/ => ['//host/share/']\n            // //host/share/x => ['//host/share/', 'x']\n            // /etc => ['/', 'etc']\n            // / => ['/']\n            if (this.isUNC()) {\n                // '' / '' / 'host' / 'share'\n                const [p0, p1, p2, p3, ...prest] = this.#patternList;\n                const [g0, g1, g2, g3, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = [p0, p1, p2, p3, ''].join('/');\n                const g = [g0, g1, g2, g3, ''].join('/');\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n            else if (this.isDrive() || this.isAbsolute()) {\n                const [p1, ...prest] = this.#patternList;\n                const [g1, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = p1 + '/';\n                const g = g1 + '/';\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n        }\n    }\n    /**\n     * The first entry in the parsed list of patterns\n     */\n    pattern() {\n        return this.#patternList[this.#index];\n    }\n    /**\n     * true of if pattern() returns a string\n     */\n    isString() {\n        return typeof this.#patternList[this.#index] === 'string';\n    }\n    /**\n     * true of if pattern() returns GLOBSTAR\n     */\n    isGlobstar() {\n        return this.#patternList[this.#index] === GLOBSTAR;\n    }\n    /**\n     * true if pattern() returns a regexp\n     */\n    isRegExp() {\n        return this.#patternList[this.#index] instanceof RegExp;\n    }\n    /**\n     * The /-joined set of glob parts that make up this pattern\n     */\n    globString() {\n        return (this.#globString =\n            this.#globString ||\n                (this.#index === 0 ?\n                    this.isAbsolute() ?\n                        this.#globList[0] + this.#globList.slice(1).join('/')\n                        : this.#globList.join('/')\n                    : this.#globList.slice(this.#index).join('/')));\n    }\n    /**\n     * true if there are more pattern parts after this one\n     */\n    hasMore() {\n        return this.length > this.#index + 1;\n    }\n    /**\n     * The rest of the pattern after this part, or null if this is the end\n     */\n    rest() {\n        if (this.#rest !== undefined)\n            return this.#rest;\n        if (!this.hasMore())\n            return (this.#rest = null);\n        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);\n        this.#rest.#isAbsolute = this.#isAbsolute;\n        this.#rest.#isUNC = this.#isUNC;\n        this.#rest.#isDrive = this.#isDrive;\n        return this.#rest;\n    }\n    /**\n     * true if the pattern represents a //unc/path/ on windows\n     */\n    isUNC() {\n        const pl = this.#patternList;\n        return this.#isUNC !== undefined ?\n            this.#isUNC\n            : (this.#isUNC =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    pl[0] === '' &&\n                    pl[1] === '' &&\n                    typeof pl[2] === 'string' &&\n                    !!pl[2] &&\n                    typeof pl[3] === 'string' &&\n                    !!pl[3]);\n    }\n    // pattern like C:/...\n    // split = ['C:', ...]\n    // XXX: would be nice to handle patterns like `c:*` to test the cwd\n    // in c: for *, but I don't know of a way to even figure out what that\n    // cwd is without actually chdir'ing into it?\n    /**\n     * True if the pattern starts with a drive letter on Windows\n     */\n    isDrive() {\n        const pl = this.#patternList;\n        return this.#isDrive !== undefined ?\n            this.#isDrive\n            : (this.#isDrive =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    this.length > 1 &&\n                    typeof pl[0] === 'string' &&\n                    /^[a-z]:$/i.test(pl[0]));\n    }\n    // pattern = '/' or '/...' or '/x/...'\n    // split = ['', ''] or ['', ...] or ['', 'x', ...]\n    // Drive and UNC both considered absolute on windows\n    /**\n     * True if the pattern is rooted on an absolute path\n     */\n    isAbsolute() {\n        const pl = this.#patternList;\n        return this.#isAbsolute !== undefined ?\n            this.#isAbsolute\n            : (this.#isAbsolute =\n                (pl[0] === '' && pl.length > 1) ||\n                    this.isDrive() ||\n                    this.isUNC());\n    }\n    /**\n     * consume the root of the pattern, and return it\n     */\n    root() {\n        const p = this.#patternList[0];\n        return (typeof p === 'string' && this.isAbsolute() && this.#index === 0) ?\n            p\n            : '';\n    }\n    /**\n     * Check to see if the current globstar pattern is allowed to follow\n     * a symbolic link.\n     */\n    checkFollowGlobstar() {\n        return !(this.#index === 0 ||\n            !this.isGlobstar() ||\n            !this.#followGlobstar);\n    }\n    /**\n     * Mark that the current globstar pattern is following a symbolic link\n     */\n    markFollowGlobstar() {\n        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)\n            return false;\n        this.#followGlobstar = false;\n        return true;\n    }\n}\n//# sourceMappingURL=pattern.js.map",
    "// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\nimport { Minimatch } from 'minimatch';\nimport { Pattern } from './pattern.js';\nconst defaultPlatform = (typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string') ?\n    process.platform\n    : 'linux';\n/**\n * Class used to process ignored patterns\n */\nexport class Ignore {\n    relative;\n    relativeChildren;\n    absolute;\n    absoluteChildren;\n    platform;\n    mmopts;\n    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform, }) {\n        this.relative = [];\n        this.absolute = [];\n        this.relativeChildren = [];\n        this.absoluteChildren = [];\n        this.platform = platform;\n        this.mmopts = {\n            dot: true,\n            nobrace,\n            nocase,\n            noext,\n            noglobstar,\n            optimizationLevel: 2,\n            platform,\n            nocomment: true,\n            nonegate: true,\n        };\n        for (const ign of ignored)\n            this.add(ign);\n    }\n    add(ign) {\n        // this is a little weird, but it gives us a clean set of optimized\n        // minimatch matchers, without getting tripped up if one of them\n        // ends in /** inside a brace section, and it's only inefficient at\n        // the start of the walk, not along it.\n        // It'd be nice if the Pattern class just had a .test() method, but\n        // handling globstars is a bit of a pita, and that code already lives\n        // in minimatch anyway.\n        // Another way would be if maybe Minimatch could take its set/globParts\n        // as an option, and then we could at least just use Pattern to test\n        // for absolute-ness.\n        // Yet another way, Minimatch could take an array of glob strings, and\n        // a cwd option, and do the right thing.\n        const mm = new Minimatch(ign, this.mmopts);\n        for (let i = 0; i < mm.set.length; i++) {\n            const parsed = mm.set[i];\n            const globParts = mm.globParts[i];\n            /* c8 ignore start */\n            if (!parsed || !globParts) {\n                throw new Error('invalid pattern object');\n            }\n            // strip off leading ./ portions\n            // https://github.com/isaacs/node-glob/issues/570\n            while (parsed[0] === '.' && globParts[0] === '.') {\n                parsed.shift();\n                globParts.shift();\n            }\n            /* c8 ignore stop */\n            const p = new Pattern(parsed, globParts, 0, this.platform);\n            const m = new Minimatch(p.globString(), this.mmopts);\n            const children = globParts[globParts.length - 1] === '**';\n            const absolute = p.isAbsolute();\n            if (absolute)\n                this.absolute.push(m);\n            else\n                this.relative.push(m);\n            if (children) {\n                if (absolute)\n                    this.absoluteChildren.push(m);\n                else\n                    this.relativeChildren.push(m);\n            }\n        }\n    }\n    ignored(p) {\n        const fullpath = p.fullpath();\n        const fullpaths = `${fullpath}/`;\n        const relative = p.relative() || '.';\n        const relatives = `${relative}/`;\n        for (const m of this.relative) {\n            if (m.match(relative) || m.match(relatives))\n                return true;\n        }\n        for (const m of this.absolute) {\n            if (m.match(fullpath) || m.match(fullpaths))\n                return true;\n        }\n        return false;\n    }\n    childrenIgnored(p) {\n        const fullpath = p.fullpath() + '/';\n        const relative = (p.relative() || '.') + '/';\n        for (const m of this.relativeChildren) {\n            if (m.match(relative))\n                return true;\n        }\n        for (const m of this.absoluteChildren) {\n            if (m.match(fullpath))\n                return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=ignore.js.map",
    "// synchronous utility for filtering entries and calculating subwalks\nimport { GLOBSTAR } from 'minimatch';\n/**\n * A cache of which patterns have been processed for a given Path\n */\nexport class HasWalkedCache {\n    store;\n    constructor(store = new Map()) {\n        this.store = store;\n    }\n    copy() {\n        return new HasWalkedCache(new Map(this.store));\n    }\n    hasWalked(target, pattern) {\n        return this.store.get(target.fullpath())?.has(pattern.globString());\n    }\n    storeWalked(target, pattern) {\n        const fullpath = target.fullpath();\n        const cached = this.store.get(fullpath);\n        if (cached)\n            cached.add(pattern.globString());\n        else\n            this.store.set(fullpath, new Set([pattern.globString()]));\n    }\n}\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nexport class MatchRecord {\n    store = new Map();\n    add(target, absolute, ifDir) {\n        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);\n        const current = this.store.get(target);\n        this.store.set(target, current === undefined ? n : n & current);\n    }\n    // match, absolute, ifdir\n    entries() {\n        return [...this.store.entries()].map(([path, n]) => [\n            path,\n            !!(n & 2),\n            !!(n & 1),\n        ]);\n    }\n}\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nexport class SubWalks {\n    store = new Map();\n    add(target, pattern) {\n        if (!target.canReaddir()) {\n            return;\n        }\n        const subs = this.store.get(target);\n        if (subs) {\n            if (!subs.find(p => p.globString() === pattern.globString())) {\n                subs.push(pattern);\n            }\n        }\n        else\n            this.store.set(target, [pattern]);\n    }\n    get(target) {\n        const subs = this.store.get(target);\n        /* c8 ignore start */\n        if (!subs) {\n            throw new Error('attempting to walk unknown path');\n        }\n        /* c8 ignore stop */\n        return subs;\n    }\n    entries() {\n        return this.keys().map(k => [k, this.store.get(k)]);\n    }\n    keys() {\n        return [...this.store.keys()].filter(t => t.canReaddir());\n    }\n}\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nexport class Processor {\n    hasWalkedCache;\n    matches = new MatchRecord();\n    subwalks = new SubWalks();\n    patterns;\n    follow;\n    dot;\n    opts;\n    constructor(opts, hasWalkedCache) {\n        this.opts = opts;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.hasWalkedCache =\n            hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();\n    }\n    processPatterns(target, patterns) {\n        this.patterns = patterns;\n        const processingSet = patterns.map(p => [target, p]);\n        // map of paths to the magic-starting subwalks they need to walk\n        // first item in patterns is the filter\n        for (let [t, pattern] of processingSet) {\n            this.hasWalkedCache.storeWalked(t, pattern);\n            const root = pattern.root();\n            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;\n            // start absolute patterns at root\n            if (root) {\n                t = t.resolve(root === '/' && this.opts.root !== undefined ?\n                    this.opts.root\n                    : root);\n                const rest = pattern.rest();\n                if (!rest) {\n                    this.matches.add(t, true, false);\n                    continue;\n                }\n                else {\n                    pattern = rest;\n                }\n            }\n            if (t.isENOENT())\n                continue;\n            let p;\n            let rest;\n            let changed = false;\n            while (typeof (p = pattern.pattern()) === 'string' &&\n                (rest = pattern.rest())) {\n                const c = t.resolve(p);\n                t = c;\n                pattern = rest;\n                changed = true;\n            }\n            p = pattern.pattern();\n            rest = pattern.rest();\n            if (changed) {\n                if (this.hasWalkedCache.hasWalked(t, pattern))\n                    continue;\n                this.hasWalkedCache.storeWalked(t, pattern);\n            }\n            // now we have either a final string for a known entry,\n            // more strings for an unknown entry,\n            // or a pattern starting with magic, mounted on t.\n            if (typeof p === 'string') {\n                // must not be final entry, otherwise we would have\n                // concatenated it earlier.\n                const ifDir = p === '..' || p === '' || p === '.';\n                this.matches.add(t.resolve(p), absolute, ifDir);\n                continue;\n            }\n            else if (p === GLOBSTAR) {\n                // if no rest, match and subwalk pattern\n                // if rest, process rest and subwalk pattern\n                // if it's a symlink, but we didn't get here by way of a\n                // globstar match (meaning it's the first time THIS globstar\n                // has traversed a symlink), then we follow it. Otherwise, stop.\n                if (!t.isSymbolicLink() ||\n                    this.follow ||\n                    pattern.checkFollowGlobstar()) {\n                    this.subwalks.add(t, pattern);\n                }\n                const rp = rest?.pattern();\n                const rrest = rest?.rest();\n                if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n                    // only HAS to be a dir if it ends in **/ or **/.\n                    // but ending in ** will match files as well.\n                    this.matches.add(t, absolute, rp === '' || rp === '.');\n                }\n                else {\n                    if (rp === '..') {\n                        // this would mean you're matching **/.. at the fs root,\n                        // and no thanks, I'm not gonna test that specific case.\n                        /* c8 ignore start */\n                        const tp = t.parent || t;\n                        /* c8 ignore stop */\n                        if (!rrest)\n                            this.matches.add(tp, absolute, true);\n                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n                            this.subwalks.add(tp, rrest);\n                        }\n                    }\n                }\n            }\n            else if (p instanceof RegExp) {\n                this.subwalks.add(t, pattern);\n            }\n        }\n        return this;\n    }\n    subwalkTargets() {\n        return this.subwalks.keys();\n    }\n    child() {\n        return new Processor(this.opts, this.hasWalkedCache);\n    }\n    // return a new Processor containing the subwalks for each\n    // child entry, and a set of matches, and\n    // a hasWalkedCache that's a copy of this one\n    // then we're going to call\n    filterEntries(parent, entries) {\n        const patterns = this.subwalks.get(parent);\n        // put matches and entry walks into the results processor\n        const results = this.child();\n        for (const e of entries) {\n            for (const pattern of patterns) {\n                const absolute = pattern.isAbsolute();\n                const p = pattern.pattern();\n                const rest = pattern.rest();\n                if (p === GLOBSTAR) {\n                    results.testGlobstar(e, pattern, rest, absolute);\n                }\n                else if (p instanceof RegExp) {\n                    results.testRegExp(e, p, rest, absolute);\n                }\n                else {\n                    results.testString(e, p, rest, absolute);\n                }\n            }\n        }\n        return results;\n    }\n    testGlobstar(e, pattern, rest, absolute) {\n        if (this.dot || !e.name.startsWith('.')) {\n            if (!pattern.hasMore()) {\n                this.matches.add(e, absolute, false);\n            }\n            if (e.canReaddir()) {\n                // if we're in follow mode or it's not a symlink, just keep\n                // testing the same pattern. If there's more after the globstar,\n                // then this symlink consumes the globstar. If not, then we can\n                // follow at most ONE symlink along the way, so we mark it, which\n                // also checks to ensure that it wasn't already marked.\n                if (this.follow || !e.isSymbolicLink()) {\n                    this.subwalks.add(e, pattern);\n                }\n                else if (e.isSymbolicLink()) {\n                    if (rest && pattern.checkFollowGlobstar()) {\n                        this.subwalks.add(e, rest);\n                    }\n                    else if (pattern.markFollowGlobstar()) {\n                        this.subwalks.add(e, pattern);\n                    }\n                }\n            }\n        }\n        // if the NEXT thing matches this entry, then also add\n        // the rest.\n        if (rest) {\n            const rp = rest.pattern();\n            if (typeof rp === 'string' &&\n                // dots and empty were handled already\n                rp !== '..' &&\n                rp !== '' &&\n                rp !== '.') {\n                this.testString(e, rp, rest.rest(), absolute);\n            }\n            else if (rp === '..') {\n                /* c8 ignore start */\n                const ep = e.parent || e;\n                /* c8 ignore stop */\n                this.subwalks.add(ep, rest);\n            }\n            else if (rp instanceof RegExp) {\n                this.testRegExp(e, rp, rest.rest(), absolute);\n            }\n        }\n    }\n    testRegExp(e, p, rest, absolute) {\n        if (!p.test(e.name))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n    testString(e, p, rest, absolute) {\n        // should never happen?\n        if (!e.isNamed(p))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n}\n//# sourceMappingURL=processor.js.map",
    "/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nimport { Minipass } from 'minipass';\nimport { Ignore } from './ignore.js';\nimport { Processor } from './processor.js';\nconst makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new Ignore([ignore], opts)\n    : Array.isArray(ignore) ? new Ignore(ignore, opts)\n        : ignore;\n/**\n * basic walking utilities that all the glob walker types use\n */\nexport class GlobUtil {\n    path;\n    patterns;\n    opts;\n    seen = new Set();\n    paused = false;\n    aborted = false;\n    #onResume = [];\n    #ignore;\n    #sep;\n    signal;\n    maxDepth;\n    includeChildMatches;\n    constructor(patterns, path, opts) {\n        this.patterns = patterns;\n        this.path = path;\n        this.opts = opts;\n        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/';\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        if (opts.ignore || !this.includeChildMatches) {\n            this.#ignore = makeIgnore(opts.ignore ?? [], opts);\n            if (!this.includeChildMatches &&\n                typeof this.#ignore.add !== 'function') {\n                const m = 'cannot ignore child matches, ignore lacks add() method.';\n                throw new Error(m);\n            }\n        }\n        // ignore, always set with maxDepth, but it's optional on the\n        // GlobOptions type\n        /* c8 ignore start */\n        this.maxDepth = opts.maxDepth || Infinity;\n        /* c8 ignore stop */\n        if (opts.signal) {\n            this.signal = opts.signal;\n            this.signal.addEventListener('abort', () => {\n                this.#onResume.length = 0;\n            });\n        }\n    }\n    #ignored(path) {\n        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);\n    }\n    #childrenIgnored(path) {\n        return !!this.#ignore?.childrenIgnored?.(path);\n    }\n    // backpressure mechanism\n    pause() {\n        this.paused = true;\n    }\n    resume() {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore stop */\n        this.paused = false;\n        let fn = undefined;\n        while (!this.paused && (fn = this.#onResume.shift())) {\n            fn();\n        }\n    }\n    onResume(fn) {\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore start */\n        if (!this.paused) {\n            fn();\n        }\n        else {\n            /* c8 ignore stop */\n            this.#onResume.push(fn);\n        }\n    }\n    // do the requisite realpath/stat checking, and return the path\n    // to add or undefined to filter it out.\n    async matchCheck(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || (await e.realpath());\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? await e.lstat() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = await s.realpath();\n            /* c8 ignore start */\n            if (target && (target.isUnknown() || this.opts.stat)) {\n                await target.lstat();\n            }\n            /* c8 ignore stop */\n        }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchCheckTest(e, ifDir) {\n        return (e &&\n            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n            (!ifDir || e.canReaddir()) &&\n            (!this.opts.nodir || !e.isDirectory()) &&\n            (!this.opts.nodir ||\n                !this.opts.follow ||\n                !e.isSymbolicLink() ||\n                !e.realpathCached()?.isDirectory()) &&\n            !this.#ignored(e)) ?\n            e\n            : undefined;\n    }\n    matchCheckSync(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || e.realpathSync();\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? e.lstatSync() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = s.realpathSync();\n            if (target && (target?.isUnknown() || this.opts.stat)) {\n                target.lstatSync();\n            }\n        }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchFinish(e, absolute) {\n        if (this.#ignored(e))\n            return;\n        // we know we have an ignore if this is false, but TS doesn't\n        if (!this.includeChildMatches && this.#ignore?.add) {\n            const ign = `${e.relativePosix()}/**`;\n            this.#ignore.add(ign);\n        }\n        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;\n        this.seen.add(e);\n        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';\n        // ok, we have what we need!\n        if (this.opts.withFileTypes) {\n            this.matchEmit(e);\n        }\n        else if (abs) {\n            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();\n            this.matchEmit(abs + mark);\n        }\n        else {\n            const rel = this.opts.posix ? e.relativePosix() : e.relative();\n            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?\n                '.' + this.#sep\n                : '';\n            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);\n        }\n    }\n    async match(e, absolute, ifDir) {\n        const p = await this.matchCheck(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    matchSync(e, absolute, ifDir) {\n        const p = this.matchCheckSync(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    walkCB(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2(target, patterns, new Processor(this.opts), cb);\n    }\n    walkCB2(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const childrenCached = t.readdirCached();\n            if (t.calledReaddir())\n                this.walkCB3(t, childrenCached, processor, next);\n            else {\n                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);\n            }\n        }\n        next();\n    }\n    walkCB3(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n    walkCBSync(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);\n    }\n    walkCB2Sync(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const children = t.readdirSync();\n            this.walkCB3Sync(t, children, processor, next);\n        }\n        next();\n    }\n    walkCB3Sync(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2Sync(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n}\nexport class GlobWalker extends GlobUtil {\n    matches = new Set();\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n    }\n    matchEmit(e) {\n        this.matches.add(e);\n    }\n    async walk() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            await this.path.lstat();\n        }\n        await new Promise((res, rej) => {\n            this.walkCB(this.path, this.patterns, () => {\n                if (this.signal?.aborted) {\n                    rej(this.signal.reason);\n                }\n                else {\n                    res(this.matches);\n                }\n            });\n        });\n        return this.matches;\n    }\n    walkSync() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        // nothing for the callback to do, because this never pauses\n        this.walkCBSync(this.path, this.patterns, () => {\n            if (this.signal?.aborted)\n                throw this.signal.reason;\n        });\n        return this.matches;\n    }\n}\nexport class GlobStream extends GlobUtil {\n    results;\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n        this.results = new Minipass({\n            signal: this.signal,\n            objectMode: true,\n        });\n        this.results.on('drain', () => this.resume());\n        this.results.on('resume', () => this.resume());\n    }\n    matchEmit(e) {\n        this.results.write(e);\n        if (!this.results.flowing)\n            this.pause();\n    }\n    stream() {\n        const target = this.path;\n        if (target.isUnknown()) {\n            target.lstat().then(() => {\n                this.walkCB(target, this.patterns, () => this.results.end());\n            });\n        }\n        else {\n            this.walkCB(target, this.patterns, () => this.results.end());\n        }\n        return this.results;\n    }\n    streamSync() {\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        this.walkCBSync(this.path, this.patterns, () => this.results.end());\n        return this.results;\n    }\n}\n//# sourceMappingURL=walker.js.map",
    "import { Minimatch } from 'minimatch';\n/**\n * Return true if the patterns provided contain any magic glob characters,\n * given the options provided.\n *\n * Brace expansion is not considered \"magic\" unless the `magicalBraces` option\n * is set, as brace expansion just turns one string into an array of strings.\n * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and\n * `'xby'` both do not contain any magic glob characters, and it's treated the\n * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`\n * is in the options, brace expansion _is_ treated as a pattern having magic.\n */\nexport const hasMagic = (pattern, options = {}) => {\n    if (!Array.isArray(pattern)) {\n        pattern = [pattern];\n    }\n    for (const p of pattern) {\n        if (new Minimatch(p, options).hasMagic())\n            return true;\n    }\n    return false;\n};\n//# sourceMappingURL=has-magic.js.map",
    "import { escape, unescape } from 'minimatch';\nimport { Glob } from './glob.js';\nimport { hasMagic } from './has-magic.js';\nexport { escape, unescape } from 'minimatch';\nexport { Glob } from './glob.js';\nexport { hasMagic } from './has-magic.js';\nexport { Ignore } from './ignore.js';\nexport function globStreamSync(pattern, options = {}) {\n    return new Glob(pattern, options).streamSync();\n}\nexport function globStream(pattern, options = {}) {\n    return new Glob(pattern, options).stream();\n}\nexport function globSync(pattern, options = {}) {\n    return new Glob(pattern, options).walkSync();\n}\nasync function glob_(pattern, options = {}) {\n    return new Glob(pattern, options).walk();\n}\nexport function globIterateSync(pattern, options = {}) {\n    return new Glob(pattern, options).iterateSync();\n}\nexport function globIterate(pattern, options = {}) {\n    return new Glob(pattern, options).iterate();\n}\n// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc\nexport const streamSync = globStreamSync;\nexport const stream = Object.assign(globStream, { sync: globStreamSync });\nexport const iterateSync = globIterateSync;\nexport const iterate = Object.assign(globIterate, {\n    sync: globIterateSync,\n});\nexport const sync = Object.assign(globSync, {\n    stream: globStreamSync,\n    iterate: globIterateSync,\n});\nexport const glob = Object.assign(glob_, {\n    glob: glob_,\n    globSync,\n    sync,\n    globStream,\n    stream,\n    globStreamSync,\n    streamSync,\n    globIterate,\n    iterate,\n    globIterateSync,\n    iterateSync,\n    Glob,\n    hasMagic,\n    escape,\n    unescape,\n});\nglob.glob = glob;\n//# sourceMappingURL=index.js.map"
  ],
  "mappings": "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",
  "debugId": "67995DDB9DA9AF3C64756E2164756E21",
  "names": []
}